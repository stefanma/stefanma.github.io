<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[分布式系统数据一致性的思考（一）]]></title>
      <url>https://stefanma.github.io/2017/04/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>说到分布式系统的设计，我们都或多或少的接触过CAP；CAP代表的是什么呢？</p>
<blockquote>
<p><strong>Consistency(一致性)，数据一致更新，所有数据变动都是同步的；所有的节点上的数据时刻保持同步；</strong><br>  <strong>Availability(可用性)，好的响应性能；每个请求都能接受到一个响应，无论响应成功或失败；</strong><br>  <strong>Partition tolerance(分区容错) ，可靠性；系统应该能持续提供服务，即使系统内部有消息丢失（分区）；</strong></p>
</blockquote>
<p>CAP理论在互联网界有着广泛的知名度，知识宽泛一点的工程师都会把其作为衡量系统设计的准则。我们非常清楚地理解了CAP：任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能得其二，因此，任何分布式系统的设计只是在三者中的不同取舍而已。（CAP在国内比价响，在国外的响力完全不如所想，相反还伴随着诸多的争论。）可以肯定的是，CAP并不适合再作为一个适应任何场景的定理，它的正确性更加适合基于原子读写的NoSQL场景。</p>
<h2 id="高可用框架中数据一致性"><a href="#高可用框架中数据一致性" class="headerlink" title="高可用框架中数据一致性"></a>高可用框架中数据一致性</h2><p>在某些电商的业务场景下，系统一般会有多个独立的服务组成的，比如在一个业务场景下，一个业务操作同时调用了A，B，C服务，需要满足要么同时成功，要么同时失败。A，B，C可能是不同的部门开发的，部署在不同机器上的远程服务。</p>
<p>对于分布式系统来说，如果不想牺牲一致性，CAP的理论告诉我们要弃用可用性，对于有些场景下是不能接受的。<br>说到数据一致性，先介绍一下数据一致性的理论基础：</p>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。当然这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。强一致性可以理解为在任意时刻，所有节点中的数据是一样的。</p>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。</p>
<blockquote>
<p>在系统的实践中，为了保证系统的高可用性，互联网系统大多将强一致性需求转换成最终一致性的需求并通过系统执行幂等性的保证，保证数据的最终一致性。</p>
</blockquote>
<h2 id="BASE和方案"><a href="#BASE和方案" class="headerlink" title="BASE和方案"></a>BASE和方案</h2><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE是指基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventual Consistency）。BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。ACID和BASE代表了两种截然相反的设计哲学；在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>
<h3 id="方案一【消息日志-本地事务】"><a href="#方案一【消息日志-本地事务】" class="headerlink" title="方案一【消息日志+本地事务】"></a>方案一【消息日志+本地事务】</h3><p>为了保证系统数据的最终一致性，可以使用本地事务来操作。<br>首先需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。<br>消息日志的方案核心是保证服务接口的幂等性。考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。<br>其中一个经典的解决方法，来达到多次重试的幂等性。最常见的场景，如果产生一笔交易，需要在交易表中增加记录，同时还要修改用户表的金额，将主要的修改操作和更新用户表的消息放在一个本地事务来完成；为了避免重复消费用户表的消息带来的问题，达到多次重试的幂等性，增加一个更新记录表来记录已经处理过的消息。<br>基于以上的方法，在第一阶段，通过本地的数据库的事务保障，增加事务表以及消息队列。<br>在第二阶段，分别读出消息队列，通过判断更新记录表来检测相关的记录是否被执行，未被执行的记录会修改用户表然后增加一条操作记录到更新记录表，事务执行成功之后再删除队列。</p>
<h3 id="方案二【分布式事务】"><a href="#方案二【分布式事务】" class="headerlink" title="方案二【分布式事务】"></a>方案二【分布式事务】</h3><p>目前很多的电商系统随着业务规模的扩大，将原来的一个单体应用拆分成多个不同职责的子系统。最开始的单体应用所有的功能都在一起，存储也在一起，可以在一个事务中，有关系数据库来保证一致性。<br>但是拆分之后就不同了，不同的子系统都有自己的存储，通过接口、RPC等方式来调用不同的子系统的服务，而不是直接操作数据库。这就涉及到一个[分布式事务]的问题。<br>对于分布式事务的解决方案，一般有2种。<br>(1)优先使用异步消息<br>在使用异步消息的时候消费者端要实现幂等。<br>实现幂等的方式有2种，一种是业务逻辑保证幂等。比如接到支付成功的消息订单状态要变成支付完成，如果当前状态是支付完成，则再收到一个支付成功的消息说明消息重复了，直接作为消息成功处理。另一种方式是如果业务逻辑无法保证幂等，则要增加一个去重表或是类似的实现。对于消息生产者端在业务数据库的同实例中放一个消息库，发消息和业务操作在同一个本地事务中。发消息的时候并不立即发出，而是向消息库中插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送成功则将消息库中消息删除，如果遇到消息队列服务异常或者网络异常，消息没有成功发出消息还留在库里，会有另一个服务不断的将这些消息扫出重新发送。</p>
<p>(2)每个业务库使用一个事务记录库<br>有的业务不适合使用异步消息的方式，事务的各个参与方都需要同步的得到结果。采取在每个参与方的本地业务库中的同实例中放一个事务记录库。<br>比如A同步调用B，C。A本地事务成功的时候更新本地事务记录状态，B和C同样。如果有一次A调用B失败了，有可能是B真的失败了，也有可能是调用超时，实际上B成功了。则由一个中心服务对比三方的事务记录表，做一个最终的决定。假设在三方的事务表中，有的成功，有的失败。</p>
<p><1>重试B，只到B成功，事务表里记录了各项调用参数等信息；</1></p>
<p><2>执行A和B的补偿操作（一种可行补偿方式就是回滚）<br>那么会有人觉得在业务库中的同实例中存放消息库或是事务记录库，会对业务侵入，业务还需要关心这个，是否是一个合理的设计？<br>实际上可以依靠运维手段来简化开发的侵入，可以采用的方法是通过DBA在MySQL实例上预初始化这个库，通过框架层（消息的客户端或事务RPC框架）透明的在背后操作这个库，业务开发人员只需要关心自己的业务逻辑，不需要访问这个库。<br>总结起来，两种方式的原理是类似的，也就是将分布式事务转换成多个本地事务，然后依靠重试等方式达到最终一致性。</2></p>
]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PostgreSQL的简介]]></title>
      <url>https://stefanma.github.io/2017/03/04/PostgreSQL%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES，现在已经更名为PostgreSQL，版本4.2为基础的对象关系型数据库管理系统（ORDBMS）。POSTGRES开创的许多概念在很久以后才出现在商业数据库中。<br>PostgreSQL支持大部分SQL标准并且提供了许多其它现代特性：</p>
<ul>
<li>复杂查询</li>
<li>外键</li>
<li>触发器</li>
<li>可更新的视图</li>
<li>事务完整性</li>
<li>多版本并发控制<br>另外，PostgreSQL可以用许多方法进行扩展，比如通过增加新的：</li>
<li>数据类型</li>
<li>函数</li>
<li>操作符</li>
<li>聚合函数</li>
<li>索引方法</li>
<li>过程语言</li>
</ul>
<p>PostgreSQL的特点如下：</p>
<ul>
<li>PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。</li>
<li>PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。</li>
<li>PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。</li>
<li>在PostgreSQL中，表可以设置为从“父”表继承其特征。</li>
<li>可以安装多个扩展以向PostgreSQL添加附加功能</li>
</ul>
<p>PostgreSQL官方宣称的是：“The world’s most advanced open source database”。PosgreSQL还是传统B+树索引的数据库，在一些场景下，比如全插入场景，其还是会比其他一些数据库要来得差很多，比如TokuDB，MongoDB。PostgreSQL另一个痛点，我想很多人没有会意识到的，就是在在线事务（OLTP）方面的性能问题。PostgreSQL在功能方面或许是比较完整的，但是真的要进入到生产环节，看的不再是简单的功能，因为大部分用户都明白日常所使用的仅是数据库提供的20%功能。MySQL 5.7现在已经可以轻松达到50W QPS的性能，并支持通过NoSQL接口可以达到100W QPS，这是PostgreSQL为什么没有能在互联网时代站住脚跟的一个重要原因之一。在线事务对性能的要求之苛刻，是普通用户所无法感知的。</p>
<p>PostgreSQL最大的优势是在线分析的场景，因为其优化器对于Join的支持堪称全面，对于复杂查询有着良好的支持，从Oracle迁移到PostgreSQL的成本会比较低。基于PostgreSQL的GreenPlum也已经开源，因此PostgreSQL目前在这方便是较为领先的。</p>
<p>官方地址：<a href="https://www.postgresql.org/" target="_blank" rel="external">https://www.postgresql.org/</a></p>
]]></content>
      
        <categories>
            
            <category> PostgreSQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对于热点缓存的思考]]></title>
      <url>https://stefanma.github.io/2017/02/04/%E5%AF%B9%E4%BA%8E%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="热点key问题"><a href="#热点key问题" class="headerlink" title="热点key问题"></a>热点key问题</h2><p>项目中通常使用 缓存+过期时间 的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新，一般情况下这种模式已经基本满足要求了。<br>但是有两个问题如果同时出现，可能就会对系统造成致命的危害：<br>1.这个key是一个热点key（例如一个重要的新闻，一个热门的八卦新闻等等），所以这种key访问量可能非常大。<br>2.缓存的构建是需要一定时间的。（可能是一个复杂计算，例如复杂的sql、多次IO、多个依赖(各种接口)等等）。</p>
<p>于是就会出现一个致命问题：在缓存失效的瞬间，有大量线程来构建缓存，造成后端负载加大，甚至可能会让系统崩溃。<br><img src="/img/mutex_key_0.jpg" alt="示意图"></p>
<h2 id="四种解决方案"><a href="#四种解决方案" class="headerlink" title="四种解决方案"></a>四种解决方案</h2><p><strong>我们的目标是：尽量少的线程构建缓存(甚至是一个) &amp;&amp; 数据一致性 &amp;&amp; 较少的潜在危险。</strong></p>
<h3 id="使用互斥锁的方案"><a href="#使用互斥锁的方案" class="headerlink" title="使用互斥锁的方案"></a>使用互斥锁的方案</h3><p><strong>这种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以。</strong><br><img src="/img/mutex_key_1.jpg" alt="示意图"><br>如果是单机，可以用synchronized或者lock来处理；<br>如果是分布式环境可以用分布式锁就可以；分布式锁，可以用memcache的add，或者redis的setnx[SET if Not eXists], zookeeper的添加节点操作。</p>
<p>redis代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;  </div><div class="line">   String value = redis.get(key);  </div><div class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </div><div class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </div><div class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></div><div class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </div><div class="line">        value = db.get(key);  </div><div class="line">        redis.set(key, value);  </div><div class="line">        redis.delete(key_mutex);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></div><div class="line">        Thread.sleep(<span class="number">50</span>);  </div><div class="line">        get(key);  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“提前”使用互斥锁"><a href="#“提前”使用互斥锁" class="headerlink" title="“提前”使用互斥锁"></a>“提前”使用互斥锁</h3><p>在value内部设置1个超时值(timeout1)，timeout1比实际的timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。</p>
<p>memcache的代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">v = memcache.get(key);  </div><div class="line"><span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;  </div><div class="line">    <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </div><div class="line">        value = db.get(key);  </div><div class="line">        memcache.set(key, value);  </div><div class="line">        memcache.delete(key_mutex);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        sleep(<span class="number">50</span>);  </div><div class="line">        retry();  </div><div class="line">    &#125;  </div><div class="line">&#125; <span class="keyword">else</span> &#123;  </div><div class="line">    <span class="keyword">if</span> (v.timeout &lt;= now()) &#123;  </div><div class="line">        <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </div><div class="line">            <span class="comment">// extend the timeout for other threads  </span></div><div class="line">            v.timeout += <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>;  </div><div class="line">            memcache.set(key, v, KEY_TIMEOUT * <span class="number">2</span>);  </div><div class="line">  </div><div class="line">            <span class="comment">// load the latest value from db  </span></div><div class="line">            v = db.get(key);  </div><div class="line">            v.timeout = KEY_TIMEOUT;  </div><div class="line">            memcache.set(key, value, KEY_TIMEOUT * <span class="number">2</span>);  </div><div class="line">            memcache.delete(key_mutex);  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            sleep(<span class="number">50</span>);  </div><div class="line">            retry();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“永远不过期”"><a href="#“永远不过期”" class="headerlink" title="“永远不过期”"></a>“永远不过期”</h3><p>其中”永远不过期”包含两层意思：<br>(1)从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。<br>(2)把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期。<br><img src="/img/mutex_key_2.png" alt="示意图"><br>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p>
<h3 id="资源保护"><a href="#资源保护" class="headerlink" title="资源保护"></a>资源保护</h3><p>可以使用提到了netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。<br><img src="/img/mutex_key_3.png" alt="示意图"></p>
<p>作为一个并发量较大的互联网应用，我们的目标有3个:</p>
<ol>
<li>加快用户访问速度，提高用户体验。</li>
<li>降低后端负载，保证系统平稳。</li>
<li>保证数据“尽可能”及时更新(要不要完全一致，取决于业务，而不是技术。)</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th style="text-align:left">解决方案</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">简单分布式锁</td>
<td style="text-align:left">思路简单;保证一致性</td>
<td style="text-align:left">代码复杂度增大;存在死锁的风险;存在线程池阻塞的风险</td>
</tr>
<tr>
<td style="text-align:left">加另外一个过期时间</td>
<td style="text-align:left">保证一致性</td>
<td style="text-align:left">代码复杂度增大;存在死锁的风险;存在线程池阻塞的风险</td>
</tr>
<tr>
<td style="text-align:left">不过期</td>
<td style="text-align:left">异步构建缓存，不会阻塞线程池</td>
<td style="text-align:left">不保证一致性;代码复杂度增大(每个value都要维护一个timekey);占用一定的内存空间(每个value都要维护一个timekey)</td>
</tr>
<tr>
<td style="text-align:left">资源隔离组件hystrix</td>
<td style="text-align:left">hystrix技术成熟，有效保证后端;hystrix监控强大</td>
<td style="text-align:left">部分访问存在降级策略</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么是区块链]]></title>
      <url>https://stefanma.github.io/2017/01/18/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      <content type="html"><![CDATA[<h2 id="比特币区块链的工作原理"><a href="#比特币区块链的工作原理" class="headerlink" title="比特币区块链的工作原理"></a>比特币区块链的工作原理</h2><p><img src="/img/blockchain-bitcoin-infographic.jpg" alt="示意图"></p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链是比特币的底层技术，它可以理解为一种公共记账的机制，它并不是一款具体的产品。其基本思想是：通过建立一组互联网上的公共账本，由网络中所有的用户共同在账本上记账与核账，来保证信息的真实性和不可篡改性。而之所以名字叫做”区块”链，顾名思义，是因为区块链存储数据的结构是由网络上一个个”存储区块”组成一根链条，每个区块中包含了一定时间内网络中全部的信息交流数据。随着时间推移，这条链会不断增长。</p>
<p>从数据的角度来看：区块链是一种分布式数据库（或称为分布式共享总账，DistributedShared Ledger），这里的“分布式”不仅体现为数据的分布式存储，也体现为数据的分布式记录（即由系统参与者来集体维护）。简单的说，区块链能实现全球数据信息的分布式记录（可以由系统参与者集体记录，而非由一个中心化的机构集中记录）与分布式存储（可以存储在所有参与记录数据的节点中，而非集中存储于中心化的机构节点中）。</p>
<p>从效果的角度来看：区块链可以生成一套记录时间先后的、不可篡改的、可信任的数据库，这套数据库是去中心化存储且数据安全能够得到有效保证的。</p>
<h2 id="交易-事务-Transactions-和区块-Blocks"><a href="#交易-事务-Transactions-和区块-Blocks" class="headerlink" title="交易/事务(Transactions)和区块(Blocks)"></a>交易/事务(Transactions)和区块(Blocks)</h2><h3 id="交易-事务-Transactions"><a href="#交易-事务-Transactions" class="headerlink" title="交易/事务(Transactions)"></a>交易/事务(Transactions)</h3><p>区块链是一个全局共享的，事务性的数据库。这个网络的每一个人都可以读取其中的记录。如果你想修改这个数据库中的东西，就必须创建一个事务，并得到其他所有人的确认。事务意味着你要做一个修改，要么被完全执行要么一点都没有执行。当你的事务被应用到这个数据库的时候，其他事务不能修改该数据库。<br>举个例子，想象一张表，里面列出了比特币所有账号的余额。当从账户A到账户B的转账请求发生时，这个数据库的事务特性确保从账户A中减掉的金额会被加到账户B上。如果因为某种原因，往账户B增加金额无法进行，那么账户A的金额也不会发生任何变化。<br>此外，一个事务会被发送者（事务的创建者）进行密码学签名。这项措施为数据库的修改增加了访问保护。在上面的比特币例子中，可以确保只有持有账户A密钥的人，才能从该账户向外转账。</p>
<h3 id="区块-Blocks"><a href="#区块-Blocks" class="headerlink" title="区块(Blocks)"></a>区块(Blocks)</h3><p>区块链要解决的一个主要难题，在比特币中被称为“双花攻击”。当网络上出现了两笔交易，都要从一个账户中转出余额时，会发生什么？一个冲突？<br>简单的回答是你不需要关心这个问题。这些交易会被排序并打包成“区块”，然后被所有参与的节点执行和分发。如果两笔交易相互冲突，排序靠后的交易会被拒绝并剔除出区块。<br>这些区块按时间排成一个线性序列。这也正是“区块链”这个词的由来。区块以一个相当规律的时间间隔加入到链上。对于比特币，这个间隔大致是10分钟。而对于以太坊，这个间隔大致是17秒，以太坊对比特币做了改进，相信未来可以做到接近实时转账，就可以运用到实时性要求比较高的商业领域。<br>作为“顺序选择机制”（通常称为“挖矿”）的一部分，一段区块链可能会时不时被回滚。但这种情况只会发生在整条链的末端。回滚涉及的区块越多，其发生的概率越小。所以你的交易可能会被回滚，甚至会被从区块链中删除。但是你等待的越久，这种情况发生的概率就越小。</p>
<h2 id="区块链可以影响大行业"><a href="#区块链可以影响大行业" class="headerlink" title="区块链可以影响大行业"></a>区块链可以影响大行业</h2><p><img src="/img/blockchain-impacting-industries.jpg" alt="示意图"></p>
<p>参考链接：<br>[<a href="http://www.teambitcoin.com/blog/2013/5/18/bitcoin-blockchain-explained-in-infographic" target="_blank" rel="external">http://www.teambitcoin.com/blog/2013/5/18/bitcoin-blockchain-explained-in-infographic</a>]<br>[<a href="https://en.wikipedia.org/wiki/Blockchain" target="_blank" rel="external">https://en.wikipedia.org/wiki/Blockchain</a>]<br>[<a href="https://datafloq.com/read/what-is-the-blockchain-and-why-is-it-so-important/2270" target="_blank" rel="external">https://datafloq.com/read/what-is-the-blockchain-and-why-is-it-so-important/2270</a>]</p>
]]></content>
      
        <categories>
            
            <category> Blockchain </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> Blockchain </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[死磕并发--并发程序设计模式（五）]]></title>
      <url>https://stefanma.github.io/2016/09/24/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>生产者-消费者模式是一个经典的多线程设计模式，它为多线程之间的协作提供了良好的解决方案。在生产者-消费者模式中，通过两类线程，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程则负责处理生产者提交的任务。生产者和消费者之间通过共享内存缓冲区进行通讯。</p>
<h3 id="生产者-消费者模式架构图"><a href="#生产者-消费者模式架构图" class="headerlink" title="生产者-消费者模式架构图"></a>生产者-消费者模式架构图</h3><p><img src="/img/productor-customer_0.png" alt="模式示意图"></p>
<blockquote>
<p>生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间共享，此外，通过缓冲区可以缓解生产者和消费者性能差。</p>
</blockquote>
<p>生产者-消费者模式的核心组件是共享内存缓存区，它作为生产者和消费者间的通信桥梁，避免了生产者和消费者的直接通信，从而将生产者和消费者进行解耦。生产者不需要知道消费者的存在，消费者也不知道生产者的存在。同时，由于内存缓冲区的存在，允许生产者和消费者在执行速度上存在时间差，无论是生产者在某一个局部时间内速度高于消费者，或是消费者在局部时间内高于生产者，都可以通过内存缓冲区得到缓解，确保系统正常运行。</p>
<p><img src="/img/productor-customer_1.png" alt="模式示意图"></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[死磕并发--并发程序设计模式（四）]]></title>
      <url>https://stefanma.github.io/2016/09/23/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h2><p>当多线程对同一个对象进行读写操作时，为了保证对象数据的一致性和正确性，有必要对对象进行同步。而同步操作对系统性能有相当的损耗。为了尽可能的去除这些同步操作，并提高并行程序性能，可以使用一种不可改变的对象，依靠对象的不变形，可以确保其在同步操作的多线程环境中依然保持内部状态的一致性和正确性。</p>
<p>不变模式天生就是多线程有好的，它的核心思想是，一个对象一旦被创建，则它的内部状态永远不会发生改变。所以，没有一个线程可以修改其内部状态和数据，同时其内部的状态绝不会发生改变。基于这些特性，对不变对象的多线程操作不需要进行同步控制。</p>
<p>同时需要注意，不变模式和只读属性是有一定的区别的。不变模式比只读属性具有更强的一致性和不变性。对只读属性的对象而言，对象本身不能被其他线程修改，但是对象自身状态却可能自行修改。</p>
<blockquote>
<p>一个对象的存活时间（对象的创建时间和当前时间的时间差）是只读的，因为任何一个第三方线程都不能修改这个属性，但是这是一个可变的属性，因为随着时间推移，存活时间时刻发生变化。而不变模式要求，无论出于什么原因，对象自建以后，其内部的状态和数据保持绝对的稳定。</p>
</blockquote>
<p>不变模式的主要的使用的场景满足以下两个条件：</p>
<p><1>当对象创建后，其内部状态和数据不再发生任何变化。</1></p>
<p><2>对象需要被共享、被多线程频繁访问。</2></p>
<h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//确保无子类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductPoJo</span> </span>&#123;</div><div class="line">	<span class="comment">//私有属性，不被其他对象获取</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer id;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> price;</div><div class="line">	<span class="comment">//创建对象时，必须指定数据，创建之后，无法进行修改</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProductPoJo</span><span class="params">(Integer id, String name, <span class="keyword">double</span> price)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.price = price;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> price;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不变模式中的实现中，final关键字起到了重要关键作用。对Class的final定义保证了不变类没有子类，确保所有的getter行为不会被修改。对属性的final定义确保所有的数据只能在对象的被构造时赋值1次，之后，就永远不再发生改变。</p>
<blockquote>
<p>不变模式通过回避问题而不是解决问题的态度来处理多线程并发访问。不变对象是不需要进行同步操作的。由于并发同步会对性能产生不良的影响，因此，在需求允许的情况下，不变模式可以提高系统的并发性能和并发量。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[死磕并发--并发程序设计模式（三）]]></title>
      <url>https://stefanma.github.io/2016/09/23/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h2><p>设想一个场景，服务器可能在短时间内承受大量的客户端的请求，客户端的请求数量已经超过了服务器本身的即时处理能力，而服务端又不能丢失任何一个客户请求。此时最佳的方案莫过于就是让客户端的请求进行排队，有服务端一个接一个的处理，这样即可以保证客户端所有的请求均不丢失，同时也避免服务器由于同时处理太多的请求而崩溃。<br>Guarded Suspension解释为保护暂停，核心的思想是仅当服务端进程准备好时，才会提供服务。</p>
<h2 id="Guarded-Suspension的理解和实现"><a href="#Guarded-Suspension的理解和实现" class="headerlink" title="Guarded Suspension的理解和实现"></a>Guarded Suspension的理解和实现</h2><h3 id="Guarded-Suspension模式的结构"><a href="#Guarded-Suspension模式的结构" class="headerlink" title="Guarded Suspension模式的结构"></a>Guarded Suspension模式的结构</h3><p>Request对象封装了客户端的请求。RequestQueue表示客户端的请求队列，由ClientThread和ServerThread共同维护。其中，ClientThread负责不断的发送请求，并将请求对象放入请求队列中。ServerThread根据自身状态，在有能力的处理请求时，从RequestQueue中提取请求对象加以处理。<br>工作流程图如下：<br><img src="/img/guarded-suspension_0.png" alt="示意图"></p>
<blockquote>
<p>Guarded Suspension模式可以确保系统仅有在有能力处理某个任务时，才会处理该任务。当系统没有能力处理任务时，它会暂存任务信息等待系统空闲。</p>
</blockquote>
<h3 id="Guarded-Suspension模式的实现"><a href="#Guarded-Suspension模式的实现" class="headerlink" title="Guarded Suspension模式的实现"></a>Guarded Suspension模式的实现</h3><p><1>RequestPoJo类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestPoJo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RequestPoJo</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"RequestPoJo [name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></1></p>
<p><2>RequestQueue类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> LinkedList&lt;RequestPoJo&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RequestPoJo <span class="title">getRequest</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//等到新的Request加入</span></div><div class="line">		<span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> (RequestPoJo) queue.remove();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addRequest</span><span class="params">(RequestPoJo request)</span></span>&#123;</div><div class="line">		<span class="comment">//添加Request</span></div><div class="line">		queue.add(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></2></p>
<p><3>ClientThread类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> RequestQueue requestQueue;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue requestQueue, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			RequestPoJo request = <span class="keyword">new</span> RequestPoJo(<span class="string">"Request ID"</span>+i+<span class="string">"Thread_name:"</span>+Thread.currentThread().getName());</div><div class="line">			requestQueue.addRequest(request);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">10</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" request end."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></3></p>
<p><4>ServerThread类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue requestQueue, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			RequestPoJo request = requestQueue.getRequest();</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">2000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" handles,"</span>+request);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></4></p>
<blockquote>
<p>Guarded Suspension模式可以在一定程度上环节系统的压力，它可以将系统的负载在时间轴上均匀的分配，有效的降低系统的瞬时负载，对提高系统的抗压力和稳定性有一定的帮助。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[死磕并发--并发程序设计模式（二）]]></title>
      <url>https://stefanma.github.io/2016/09/22/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h2><p>Master-Worker模式是常用的并发模式之一。中心就是，系统中有两类进程协调工作，Master进程和Worker进程，Master负责接收和分配任务，Worker负责处理子任务，当各个子任务处理完毕后，将结果返回给Master进程，Master进行归纳和汇总，得到系统的最终结果。<br>处理过程如下：<br><img src="/img/master-worker_0.png" alt="示意图"></p>
<p>Master-Worker模式的好处能够将一个大任务分解成若干的小任务执行，并行执行，提高系统的吞吐量。任务一旦提交，Master进程就会分配任务并立即返回，并不会等待系统全部处理完成后再返回，其处理过程是异步的。因此，Client不会出现等待的现象。</p>
<h2 id="Master-Worker理解和实现"><a href="#Master-Worker理解和实现" class="headerlink" title="Master-Worker理解和实现"></a>Master-Worker理解和实现</h2><h3 id="Master-Worker模式结构"><a href="#Master-Worker模式结构" class="headerlink" title="Master-Worker模式结构"></a>Master-Worker模式结构</h3><p>Master-Worker模式结构相对比较简单。Master进程为主要进程，维护一个<code>Worker进程队列、子任务队列和子结果集</code>。Worker进程队列中的Worker进程，不停的从任务队列中提取要处理的子任务，并将子任务的结果写入结果集中。<br><img src="/img/master-worker_1.png" alt="示意图"></p>
<h3 id="Master-Worker模式简单的代码实现"><a href="#Master-Worker模式简单的代码实现" class="headerlink" title="Master-Worker模式简单的代码实现"></a>Master-Worker模式简单的代码实现</h3><p><1>Master的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//任务队列</span></div><div class="line">	<span class="keyword">protected</span> Queue&lt;Object&gt; workQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</div><div class="line">	<span class="comment">//Work进程队列</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Thread&gt; threadMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	<span class="comment">//子任务处理结果集</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//是否所有的子任务都结束了</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Thread&gt; entry : threadMap.entrySet()) &#123;</div><div class="line">			<span class="keyword">if</span> (entry.getValue().getState() != Thread.State.TERMINATED) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//构造Master，</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(Worker worker, <span class="keyword">int</span> counrWorker)</span></span>&#123;</div><div class="line">		worker.setWorkQueue(workQueue);</div><div class="line">		worker.setResultMap(resultMap);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counrWorker; i++) &#123;</div><div class="line">			threadMap.put(Integer.toString(i), <span class="keyword">new</span> Thread(worker,Integer.toString(i)));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//提交一个任务</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Object task)</span></span>&#123;</div><div class="line">		workQueue.add(task);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//运行Woker进程，进行处理</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Thread&gt; entry : threadMap.entrySet()) &#123;</div><div class="line">			entry.getValue().start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//获取结果集</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getResultMap</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> resultMap;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></1></p>
<p><2>Worker的实现以及子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="comment">//任务队列，获取子任务</span></div><div class="line">	<span class="keyword">protected</span> Queue&lt;Object&gt; workQueue;</div><div class="line">	<span class="comment">//子任务处理的结果集</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Object&gt; resultMap;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkQueue</span><span class="params">(Queue&lt;Object&gt; workQueue)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultMap</span><span class="params">(Map&lt;String, Object&gt; resultMap)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.resultMap = resultMap;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//子任务处理逻辑，可以用于子类的实现具体逻辑</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object input)</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> input;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//获取子任务</span></div><div class="line">			Object input = workQueue.poll();</div><div class="line">			<span class="keyword">if</span> (input == <span class="keyword">null</span> ) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//处理子任务</span></div><div class="line">			Object res = handle(input);</div><div class="line">			<span class="comment">//结果写入结果集</span></div><div class="line">			resultMap.put(Integer.toString(input.hashCode()), res);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></2></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object input)</span> </span>&#123;</div><div class="line">		Integer d = (Integer)input;</div><div class="line">		<span class="keyword">return</span> d*d*d;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><3>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算1--100的立方的和</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Master master = <span class="keyword">new</span> Master(<span class="keyword">new</span> PlusWorker(), <span class="number">5</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</div><div class="line">			master.submit(i);</div><div class="line">		&#125;</div><div class="line">		master.execute();</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">		Map&lt;String, Object&gt; resultMap = master.getResultMap();</div><div class="line">		<span class="keyword">while</span> (resultMap.size() &gt;<span class="number">0</span> || !master.isComplete()) &#123;</div><div class="line">			Set&lt;String&gt; keys = resultMap.keySet();</div><div class="line">			String key = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">for</span> (String k:keys) &#123;</div><div class="line">				key = k;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			Integer i=<span class="keyword">null</span>;</div><div class="line">			<span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">				i = (Integer) resultMap.get(key);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</div><div class="line">				res+=i;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">				resultMap.remove(key);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"final res="</span>+res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></3></p>
<blockquote>
<p>Master-Worker模式是一种将任务串行化的方案，被分解的子任务在系统中可以并行的处理。同时，如果需要，Master进程不需要等待所有的子任务都完成计算，就可以根据已有的部分结果集计算最终结果。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[死磕并发--并发程序设计模式（一）]]></title>
      <url>https://stefanma.github.io/2016/09/20/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>对于Future模式有点像期货市场的“期货”，是“对未来的一种凭证”；例如：我在期货交易中心买了期货，交钱之后，会拿到一个期货的凭证，这个凭证告诉我等XXXX年某个时候可以拿这个凭证来拿对方的物品，而现在我是没有办法拿到物品的，需要等到协定的时间来取。<br>对于程序代码来讲，实现了Future模式的客户端在程序处理任务还没有返回结果时，而是去调用了其他业务逻辑的，充分利用等待时间。在完成了对其他业务的处理后，最后再使用返回比较慢的程序数据，在整个调用过程中，就不存在了无所谓的等待，充分利用所有的时间片段，从而提高整个系统的响应速度。</p>
<h2 id="模式流程图"><a href="#模式流程图" class="headerlink" title="模式流程图"></a>模式流程图</h2><p>基本的模式流程图<br><img src="/img/future_model_0.png" alt="模式流程图"></p>
<h2 id="Future模式Java实现"><a href="#Future模式Java实现" class="headerlink" title="Future模式Java实现"></a>Future模式Java实现</h2><p>1.Main函数调用：<br>ApplicationTest主要是client发起请求，并返回数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		ClientMain client = <span class="keyword">new</span> ClientMain();</div><div class="line">		<span class="comment">// 这里会立即返回，因为获取的是FutureData，而非RealData</span></div><div class="line">		Data data = client.request(<span class="string">"name"</span>);</div><div class="line">		System.out.println(<span class="string">"请求完毕！"</span>);  </div><div class="line">		<span class="comment">// 这里可以用一个sleep代替对其他业务逻辑的处理</span></div><div class="line">		<span class="comment">// 在处理这些业务逻辑过程中，RealData也正在创建，从而充分了利用等待时间</span></div><div class="line">		Thread.sleep(<span class="number">2000</span>);</div><div class="line">		<span class="comment">// 使用真实数据</span></div><div class="line">		System.out.println(<span class="string">"数据="</span> + data.getResult());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.ClientMain实现：<br>ClientMain主要实现了FutureData，开启构造RealData的线程，接收请求后很快的返回FutureData。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String string)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> FutureData futureData = <span class="keyword">new</span> FutureData();</div><div class="line">		<span class="comment">// 开启一个新的线程来构造真实数据</span></div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// RealData的构建很慢，所以放在单独的线程中运行</span></div><div class="line">				RealData realData = <span class="keyword">new</span> RealData(string);</div><div class="line">				futureData.setRealData(realData);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		<span class="keyword">return</span> futureData; <span class="comment">// 先直接返回FutureData</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.Data的实现：<br>Data是一个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.FutureData的实现：<br>FutureData实现了一个快速返回的RealData的包装。当使用FutureData的getResult()方法时，程序会阻塞，等待RealData被注入到程序中，才使用RealData的getResult()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//FutureData是Future模式的关键，它实际上是真实数据RealData的代理，封装了获取RealData的等待过程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// FutureData是RealData的封装</span></div><div class="line">	RealData realData = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">// 是否已经准备好</span></div><div class="line">	<span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (isReady)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.realData = realData;</div><div class="line">		isReady = <span class="keyword">true</span>;</div><div class="line">		notifyAll(); <span class="comment">// RealData已经被注入到FutureData中了，通知getResult()方法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (!isReady) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> realData.getResult();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.RealData实现：<br>RealData是最终需要使用的数据模型，构造速度比较慢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span> String data;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String data)</span> </span>&#123;</div><div class="line">    	<span class="comment">//RealData的构建过程可能会很慢，需要用户等很长的时间</span></div><div class="line">    	System.out.println(<span class="string">"RealData data:"</span>+data);</div><div class="line">    	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            	sb.append(<span class="string">"++"</span>+data);</div><div class="line">                Thread.sleep(<span class="number">200</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.data = sb.toString();</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		 <span class="keyword">return</span> data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JDK内置的实现"><a href="#JDK内置的实现" class="headerlink" title="JDK内置的实现"></a>JDK内置的实现</h2><p>在JDK自带的实现中，有关实现Future模式的核心结构如图:<br><img src="/img/future_model_1.png" alt="Future模式的核心结构图"></p>
<p>FutureTask是最为重要的模块，实现了RunnableFuture接口，而RunnableFuture继承Runnable和Future，实现了Runnable的接口，作为单独的线程运行。在run()的方法中维护了Callable，并维护该对象返回的对象。当FutureTask.get()方法时，将返回Callable接口的返回对象。<br><img src="/img/future_model_2.png" alt="JDK代码"></p>
<blockquote>
<p>Future模式的核心是在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑，从而充分的利用计算机资源。</p>
</blockquote>
<h2 id="FutureTask使用场景"><a href="#FutureTask使用场景" class="headerlink" title="FutureTask使用场景"></a>FutureTask使用场景</h2><p>未完待续……</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有关BlockingQueue和门徒的说说（一）]]></title>
      <url>https://stefanma.github.io/2016/09/18/%E6%9C%89%E5%85%B3BlockingQueue%E5%92%8C%E5%AD%90%E7%B1%BB%E7%9A%84%E8%AF%B4%E8%AF%B4/</url>
      <content type="html"><![CDATA[<h2 id="关注BlockingQueue的由来"><a href="#关注BlockingQueue的由来" class="headerlink" title="关注BlockingQueue的由来"></a>关注BlockingQueue的由来</h2><p>JDK中提供了一套Executors框架，可以有效的帮助开发人员进行线程的控制。在项目中应用Executors这个类实现代码的时候，看到newFixedThreadPool(),newSingleThreadExecutor(),newCachedThreadPool()等的实现中利用了BlockingQueue的实现类来过工作队列。<br>BlockingQueue是一个接口,主要的实现类有ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue。<br>Java API中的实现类：<br><img src="/img/blocking_queue_0.png" alt="截图"></p>
<p>在java.util.concurrent包中所有Queue的UML结构图：<br><img src="/img/blocking_queue_1.jpg" alt="结构图"></p>
<h2 id="BlockingQueue的门徒"><a href="#BlockingQueue的门徒" class="headerlink" title="BlockingQueue的门徒"></a>BlockingQueue的门徒</h2><p>主要探究ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue这4个实现类[基于Java8]。</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个线程安全的、基于数组、有界的（初始化的时候必须要指定队列长度，且指定长度之后不允许进行修改）、阻塞的、FIFO队列。向已满的队列中存放元素导致操作阻塞，试图从空队列中提取元素导致类似阻塞。基于ReentrantLock 来实现线程安全，所以提供了ReentrantLock所能支持的公平性选择。<br>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">/** Main lock guarding all access */</span></div><div class="line">   <span class="keyword">final</span> ReentrantLock lock;</div><div class="line">.......</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">       <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</div><div class="line">       lock = <span class="keyword">new</span> ReentrantLock(fair);</div><div class="line">       notEmpty = lock.newCondition();</div><div class="line">       notFull =  lock.newCondition();</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>ArrayBlockingQueue有不同的几个数据添加方法:add、offer、put方法。<br><strong>add方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (offer(e))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>offer方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    checkNotNull(e);<span class="comment">// 不允许元素为空</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();<span class="comment">// 加锁，保证调用offer方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count == items.length)<span class="comment">// 如果队列已满</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 直接返回false，添加失败</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            enqueue(e);<span class="comment">// 数组没满的话调用enqueue方法</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 返回true，添加成功</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用offer方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Inserts element at current put position, advances, and signals.</div><div class="line"> * Call only when holding lock.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[putIndex] == null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;<span class="comment">// 放数据索引+1，当索引满了变成0</span></div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;<span class="comment">// 元素个数+1</span></div><div class="line">    notEmpty.signal();<span class="comment">// 使用条件对象notEmpty通知</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>put方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);<span class="comment">// 不允许元素为空</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();<span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length)<span class="comment">// 如果队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里</span></div><div class="line">            notFull.await();<span class="comment">// 线程阻塞并被挂起，同时释放锁</span></div><div class="line">        enqueue(e); <span class="comment">// 调用enqueue方法</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();<span class="comment">// 释放锁，让其他线程可以调用put方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>ArrayBlockingQueue的添加数据方法有add,put,offer这3个方法，总结：</p>
<p><1>add方法内部调用offer方法，如果队列满了，抛出IllegalStateException异常，否则返回true;</1></p>
<p><2>offer方法如果队列满了，返回false，否则返回true;</2></p>
<p><3><strong>add方法和offer方法不会阻塞线程，put方法如果队列满了会阻塞线程，直到有线程消费了队列里的数据才有可能被唤醒;</strong><br>这3个方法内部都会使用可重入锁保证原子性。</3></p>
</blockquote>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>ArrayBlockingQueue有不同的几个数据删除方法:poll、take、remove方法。<br><strong>poll方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();<span class="comment">// 加锁，保证调用poll方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();<span class="comment">// 如果队列里没元素了，返回null，否则调用dequeue方法</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();<span class="comment">// 释放锁，让其他线程可以调用poll方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Extracts element at current take position, advances, and signals.</div><div class="line"> * Call only when holding lock.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[takeIndex] != null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    E x = (E) items[takeIndex];<span class="comment">// 得到取索引位置上的元素</span></div><div class="line">    items[takeIndex] = <span class="keyword">null</span>;<span class="comment">// 对应取索引上的数据清空</span></div><div class="line">    <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">// 取数据索引+1，当索引满了变成0</span></div><div class="line">        takeIndex = <span class="number">0</span>;</div><div class="line">    count--;<span class="comment">// 元素个数-1</span></div><div class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</div><div class="line">        itrs.elementDequeued();</div><div class="line">    notFull.signal();<span class="comment">// 使用条件对象notFull通知</span></div><div class="line">    <span class="keyword">return</span> x;<span class="comment">// 返回元素</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>take方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();<span class="comment">// 加锁，保证调用take方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)<span class="comment">// 如果队列空，阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span></div><div class="line">            notEmpty.await();<span class="comment">// 线程阻塞并被挂起，同时释放锁</span></div><div class="line">        <span class="keyword">return</span> dequeue();<span class="comment">// 调用dequeue方法</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();<span class="comment">// 释放锁，让其他线程可以调用take方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>remove方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();<span class="comment">// 加锁，保证调用remove方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</div><div class="line">            <span class="keyword">int</span> i = takeIndex;</div><div class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 遍历元素</span></div><div class="line">                <span class="keyword">if</span> (o.equals(items[i])) &#123;<span class="comment">// 两个对象相等的话</span></div><div class="line">                    removeAt(i);<span class="comment">// 调用removeAt方法</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">// 删除成功，返回true</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (++i == items.length)<span class="comment">// 元素都被删除，索引记为0</span></div><div class="line">                    i = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">while</span> (i != putIndex);<span class="comment">// 元素都被删除</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();<span class="comment">// 释放锁，让其他线程可以调用remove方法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>ArrayBlockingQueue的删除数据方法有poll,take,remove这3个方法，总结：</p>
<p><1>poll方法对于队列为空的情况，返回null，否则返回队列头部元素;</1></p>
<p><2>remove方法取的元素是基于对象的下标值，删除成功返回true，否则返回false;</2></p>
<p><3><strong>poll方法和remove方法不会阻塞线程;</strong></3></p>
<p><4><strong>take方法对于队列为空的情况，会阻塞并挂起当前线程，直到有数据加入到队列中;</strong><br>这3个方法内部都会调用notFull.signal方法通知正在等待队列满情况下的阻塞线程。</4></p>
</blockquote>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue是一个基于单向链表的、范围任意的（其实是有界的）、FIFO阻塞队列。访问与移除操作是在队头进行，添加操作是在队尾进行，并分别使用不同的锁进行保护，只有在可能涉及多个节点的操作才同时对两个锁进行加锁。队列是否为空、是否已满仍然是通过元素数量的计数器（count）进行判断的，由于可以同时在队头、队尾并发地进行访问、添加操作，所以这个计数器必须是线程安全的，这里使用了一个原子类 AtomicInteger，这就决定了它的容量范围是： 1 – Integer.MAX_VALUE。<br>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">this</span>.capacity = capacity;</div><div class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于同时使用了两把锁，在需要同时使用两把锁时，加锁顺序与释放顺序是非常重要的：必须以固定的顺序进行加锁，再以与加锁顺序的相反的顺序释放锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Lock held by take, poll, etc */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">/** Lock held by put, offer, etc */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</div></pre></td></tr></table></figure></p>
<h4 id="添加数据-1"><a href="#添加数据-1" class="headerlink" title="添加数据"></a>添加数据</h4><p>LinkedBlockingQueue有不同的几个数据添加方法：offer、put方法。<br><strong>offer方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">// 不允许空元素</span></div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">if</span> (count.get() == capacity)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// 如果容量满了，返回false</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);<span class="comment">// 容量没满，以新元素构造节点</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    putLock.lock();<span class="comment">// 放锁加锁，保证调用offer方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;<span class="comment">// 再次判断容量是否已满，因为可能拿锁在进行消费数据，没满的话继续执行</span></div><div class="line">            enqueue(node);<span class="comment">// 节点添加到链表尾部</span></div><div class="line">            c = count.getAndIncrement();<span class="comment">// 元素个数+1</span></div><div class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)<span class="comment">// 如果容量还没满</span></div><div class="line">                notFull.signal();<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();<span class="comment">// 释放放锁，让其他线程可以调用offer方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化</span></div><div class="line">        signalNotEmpty();<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span></div><div class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>put方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">// 不允许空元素</span></div><div class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></div><div class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);<span class="comment">// 以新元素构造节点</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    putLock.lockInterruptibly();<span class="comment">// 放锁加锁，保证调用put方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Note that count is used in wait guard even though it is</div><div class="line">         * not protected by lock. This works because count can</div><div class="line">         * only decrease at this point (all other puts are shut</div><div class="line">         * out by lock), and we (or some other waiting put) are</div><div class="line">         * signalled if it ever changes from capacity. Similarly</div><div class="line">         * for all other uses of count in other wait guards.</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;<span class="comment">// 如果容量满了</span></div><div class="line">            notFull.await();<span class="comment">// 阻塞并挂起当前线程</span></div><div class="line">        &#125;</div><div class="line">        enqueue(node); <span class="comment">// 节点添加到链表尾部</span></div><div class="line">        c = count.getAndIncrement(); <span class="comment">// 元素个数+1</span></div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)<span class="comment">// 如果容量还没满</span></div><div class="line">            notFull.signal();<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用put方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty(); <span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>LinkedBlockingQueue的添加数据方法put,offer跟ArrayBlockingQueue一样，不同的是它们的底层实现不一样。<br>ArrayBlockingQueue中放入数据阻塞的时候，需要消费数据才能唤醒。<br><strong>而LinkedBlockingQueue中放入数据阻塞的时候，因为它内部有2个锁，可以并行执行放入数据和消费数据，不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的时候如果容量还没满，也会唤醒插入阻塞的线程。</strong></p>
</blockquote>
<h4 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h4><p>LinkedBlockingQueue有不同的几个数据删除方法:poll、take、remove方法。<br><strong>poll方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)<span class="comment">// 如果元素个数为0</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回null</span></div><div class="line">    E x = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lock();<span class="comment">// 拿锁加锁，保证调用poll方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断队列里是否还有数据</span></div><div class="line">            x = dequeue();<span class="comment">// 删除头结点</span></div><div class="line">            c = count.getAndDecrement(); <span class="comment">// 元素个数-1</span></div><div class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</div><div class="line">                notEmpty.signal();<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();<span class="comment">// 释放拿锁，让其他线程可以调用poll方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)<span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span></div><div class="line">        signalNotFull();<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程</span></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>take方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    E x;</div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</div><div class="line">    takeLock.lockInterruptibly();<span class="comment">// 拿锁加锁，保证调用take方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;<span class="comment">// 如果队列里已经没有元素了</span></div><div class="line">            notEmpty.await(); <span class="comment">// 阻塞并挂起当前线程</span></div><div class="line">        &#125;</div><div class="line">        x = dequeue();<span class="comment">// 删除头结点</span></div><div class="line">        c = count.getAndDecrement();<span class="comment">// 元素个数-1</span></div><div class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">// 如果队列里还有元素</span></div><div class="line">            notEmpty.signal();<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        takeLock.unlock();<span class="comment">// 释放拿锁，让其他线程可以调用take方法</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == capacity)<span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化</span></div><div class="line">        signalNotFull();<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span></div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>remove方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    fullyLock();<span class="comment">// remove操作要移动的位置不固定，2个锁都需要加锁</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;<span class="comment">// 从链表头结点开始遍历</span></div><div class="line">             p != <span class="keyword">null</span>;</div><div class="line">             trail = p, p = p.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">// 判断是否找到对象</span></div><div class="line">                unlink(p, trail);<span class="comment">// 修改节点的链接信息，同时调用notFull的signal方法</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        fullyUnlock();<span class="comment">// 2个锁解锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    putLock.lock();</div><div class="line">    takeLock.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>LinkedBlockingQueue的take方法对于没数据的情况下会阻塞，poll方法删除链表头结点，remove方法删除指定的对象。<br>需要注意的是remove方法由于要删除的数据的位置不确定，需要2个锁同时加锁。</p>
</blockquote>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue能使队列保持FIFO，可以在元素取完时,一直处于等待状态,PriorityBlockingQueue中用object[]来存储队列，队列中的元素需实现Comparable接口，队列通过这个接口的compare方法确定对象的priority。</p>
<h4 id="添加数据-2"><a href="#添加数据-2" class="headerlink" title="添加数据"></a>添加数据</h4><p>PriorityBlockingQueue有不同的几个数据添加方法:add、offer、put方法。<br><strong>add方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> offer(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>offer方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">// 不允许空元素，空元素抛出异常</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();<span class="comment">// 拿锁加锁，保证调用offer方法的时候只有1个线程</span></div><div class="line">    <span class="keyword">int</span> n, cap;</div><div class="line">    Object[] array;</div><div class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</div><div class="line">        tryGrow(array, cap);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</div><div class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</div><div class="line">            siftUpComparable(n, e, array);<span class="comment">// 插入元素，向上调整</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            siftUpUsingComparator(n, e, array, cmp);</div><div class="line">        size = n + <span class="number">1</span>;</div><div class="line">        notEmpty.signal();<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();<span class="comment">// 释放放锁</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</div><div class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">        Object e = array[parent];</div><div class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>) <span class="comment">// 当待插入元素比当前位置的父元素大的时候，代表待插入元素可以插入到当前位置。</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        array[k] = e;</div><div class="line">        k = parent;</div><div class="line">    &#125;</div><div class="line">    array[k] = key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></div><div class="line">                                   Comparator&lt;? <span class="keyword">super</span> T&gt; cmp) &#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">        Object e = array[parent];</div><div class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        array[k] = e;</div><div class="line">        k = parent;</div><div class="line">    &#125;</div><div class="line">    array[k] = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>PriorityBlockingQueue添加新元素的时候不是将全部的元素进行顺序排序，而是从某个指定的位置开始将新元素与新添加的作比较，一直比较到队列头，这样可以保证PriorityBlockingQueue队列头一定是优先级最高的。</p>
</blockquote>
<p><strong>put方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    offer(e); <span class="comment">// never need to block</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="删除数据-2"><a href="#删除数据-2" class="headerlink" title="删除数据"></a>删除数据</h4><p>LinkedBlockingQueue有不同的几个数据删除方法:poll、take、remove方法。<br><strong>poll方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> dequeue();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>take方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    E result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="keyword">null</span>)</div><div class="line">            notEmpty.await();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>remove方法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = indexOf(o);</div><div class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        removeAt(i);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue不像ArrayBlockingQueue或LinkedBlockingQueue，其内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。<br>每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。<br>SynchronousQueue的一个使用场景是在Executors.newCachedThreadPool()线程池里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>
<h4 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h4><p>此队列设计的理念类似于”单工模式”，对于每个put/offer操作，必须等待一个take/poll操作,类似于”火把传递”:一个火把传递地他人,需要2个人”触手可及”才行. 因为这种策略,最终导致队列中并没有一个真正的元素；这是一种pipleline思路的基于queue的”操作传递”。</p>
<ul>
<li>void put(E o):向队列提交一个元素,阻塞直到其他线程take或者poll此元素；</li>
<li>boolean offer(E o):向队列中提交一个元素,如果此时有其他线程正在被take阻塞(即其他线程已准备接收)或者”碰巧”有poll操作,那么将返回true,否则返回false；</li>
<li>E take():获取并删除一个元素,阻塞直到有其他线程offer/put；</li>
<li>boolean poll():获取并删除一个元素,如果此时有其他线程正在被put阻塞(即其他线程提交元素正等待被接收)或者”碰巧”有offer操作,那么将返回true,否则返回false；</li>
<li>E peek():总会返回null,硬编码。</li>
</ul>
<p>SynchronousQueue经常用来,一端或者双端严格遵守”单工”(单工作者)模式的场景,队列的两个操作端分别是productor和consumer。常用于一个productor多个consumer的场景。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排查Java应用CPU使用率过高]]></title>
      <url>https://stefanma.github.io/2016/09/13/%E6%8E%92%E6%9F%A5Java%E5%BA%94%E7%94%A8CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BF%87%E9%AB%98/</url>
      <content type="html"><![CDATA[<h2 id="CPU使用率过高"><a href="#CPU使用率过高" class="headerlink" title="CPU使用率过高"></a>CPU使用率过高</h2><p>作为工程师我们会碰到Java应用某台机器cpu比较高的情况，在允许的情况下重启后基本上都会恢复正常，但是治标不治本，过上一段时间后还会出现CPU过高的问题。<br>一般的正常情况下：<br>应用使用CPU在 ：30%–40%<br>异常情况下：<br>CPU利用率在：80%—100%<br>一般Java应用CPU过高基本上有以下原因：<br>1.程序计算比较密集（计算密集型应用）；<br>2.程序死循环；<br>3.程序逻请求堵塞；<br>有的极端情况CPU甚至会飙到200%以上。</p>
<p>不过有时候还是具体问题具体分析，懂得如何查找和分析问题的原因和步骤对于问题的解决有这重要意义。</p>
<h2 id="定位和解决"><a href="#定位和解决" class="headerlink" title="定位和解决"></a>定位和解决</h2><p>碰到这样的问题该怎么定位和解决这类问题？</p>
<h3 id="基本的步骤"><a href="#基本的步骤" class="headerlink" title="基本的步骤"></a>基本的步骤</h3><p>（1）通过top命令找到可疑进程PID，找出消耗资源最高的线程 ；<br><img src="/img/java_jvm_0.png" alt="示意图"><br>（2）通过ps aux | grep PID命令，可以进一步确定是tomcat进程出现了问题；<br><img src="/img/java_jvm_1.png" alt="示意图"><br>（3）通过ps -mp pid -o THREAD,tid,time 显示线程列表；<br><img src="/img/java_jvm_2.png" alt="示意图"><br>（4）通过printf “%x\n” tid 将需要的线程ID转换为16进制格式；<br>（5）通过jstack 命令打印线程的堆栈信息；</p>
<blockquote>
<p>jstack pid |grep tid -A 30 或者 jstack pid |grep tid -A 60</p>
</blockquote>
<p>jstack主要用来查看某个Java进程内的线程堆栈信息，jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，它在JVM性能调优中使用得非常多。</p>
<p>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jstack [option] pid</div><div class="line">jstack [option] executable core</div><div class="line">jstack [option] [server-id@]remote-hostname-or-ip</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux查找命令小记]]></title>
      <url>https://stefanma.github.io/2016/09/09/Linux%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>小记</strong><br>在Linux系统中查找文件，定位相关的路径是攻城狮们经常遇到的，Linux就向是一个相当大的仓库，需要及时的准确的找到自己想要的路径和文件，那就需要比较好的搜索工具；搜索工具好不好关系到定位问题的精准和效率。今天在DEV环境需要查找自己很久之前部署的Redis，文件路径由于时间比较久远已经忘记了，怎么精确的快速找到自己部署的应用。经历了一段小的寻找路程，虽然耗时不是那么多的时间，记录下来以便自己和看这篇文章的同学参考。</p>
<h2 id="查找Redis部署路径"><a href="#查找Redis部署路径" class="headerlink" title="查找Redis部署路径"></a>查找Redis部署路径</h2><p>(1)首先我要确保我用的这台服务器上确实有Redis在运行着；<br>查看如下图命令和操作：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# ps -ef|grep redis</div><div class="line">root      5705     1  0  2016 ?        05:32:56 ./redis-server *:6379    </div><div class="line">root     30763 29277  0 16:52 pts/3    00:00:00 grep redis</div><div class="line">[root@vm-test01 /]#</div></pre></td></tr></table></figure></p>
<p>(2)使用find命令<br>查看如下图命令和操作：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# find / -name redis-server</div><div class="line">/home/redis/redis-server</div></pre></td></tr></table></figure></p>
<h2 id="Linux查找命令"><a href="#Linux查找命令" class="headerlink" title="Linux查找命令"></a>Linux查找命令</h2><p><strong>可以使用下面的一些命令来搜索：</strong><br><code>which        查看可执行文件的位置</code><br><code>whereis      查看文件的位置</code><br><code>locate       配合数据库查看文件位置</code><br><code>find         实际搜寻硬盘查询文件名称</code></p>
<h3 id="Linux查找命令详解"><a href="#Linux查找命令详解" class="headerlink" title="Linux查找命令详解"></a>Linux查找命令详解</h3><p>1.which<br>语法: which 可执行文件名称</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]#  which passwd</div><div class="line">/usr/bin/passwd</div></pre></td></tr></table></figure>
<blockquote>
<p>which是通过 PATH环境变量到该路径内查找可执行文件，所以基本的功能是<code>寻找可执行文件</code>.</p>
</blockquote>
<p>2.whereis<br>语法: whereis [-bmsu] 文件或者目录名称<br>参数说明：<br>-b: 只找二进制文件<br>-m: 只找在说明文件manual路径下的文件<br>-s: 只找source源文件<br>-u: 没有说明文档的文件</p>
<p>将和passwd文件相关的文件都查找出来<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]#  whereis passwd</div><div class="line">passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz</div></pre></td></tr></table></figure></p>
<p>只将二进制文件查找出来<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# whereis -b passwd</div><div class="line">passwd: /usr/bin/passwd /etc/passwd</div></pre></td></tr></table></figure></p>
<blockquote>
<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p>
</blockquote>
<p>3.locate<br>语法: locate 文件或者目录名称</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]#  locate redis</div><div class="line">/home/quartz/webapps/quartz-service/WEB-INF/classes/spring/applicationContext-redis.xml</div><div class="line">/home/redis/dump.rdb</div><div class="line">/home/redis/redis-benchmark</div><div class="line">/home/redis/redis-cli</div><div class="line">/home/redis/redis-server</div><div class="line">/home/redis/redis.conf</div><div class="line">/home/redis/redis.pid</div><div class="line">/home/redis/redis1.conf</div><div class="line">/home/redis/redis_init_script</div><div class="line">/home/redis/temp-12938.rdb</div><div class="line">/home/redis/temp-3575.rdb</div><div class="line">···············</div></pre></td></tr></table></figure>
<p>4.find<br>语法: find 路径 参数<br>参数说明：<br>时间查找参数：<br>-atime n :将n<em>24小时内存取过的的文件列出来<br>-ctime n :将n</em>24小时内改变、新增的文件或者目录列出来<br>-mtime n :将n*24小时内修改过的文件或者目录列出来<br>-newer file :把比file还要新的文件列出来</p>
<p>名称查找参数：<br>-gid n       :寻找群组ID为n的文件<br>-group name  :寻找群组名称为name的文件<br>-uid n       :寻找拥有者ID为n的文件<br>-user name   :寻找用户者名称为name的文件<br>-name file   :寻找文件名为file的文件（可以使用通配符）</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# find / -name redis-server</div><div class="line">/home/redis/redis-server</div></pre></td></tr></table></figure>
<blockquote>
<p>find命令所查找的目录路径，是在硬盘上遍历查找，因此非常消耗硬盘的资源，而且效率也非常低。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[让MySQL支持中文排序的实现方法]]></title>
      <url>https://stefanma.github.io/2016/09/07/%E8%AE%A9MySQL%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="让MySQL支持中文排序"><a href="#让MySQL支持中文排序" class="headerlink" title="让MySQL支持中文排序"></a>让MySQL支持中文排序</h2><p>如果在mysql中使用字符集为utf8，想要对中文字段用order by chinese_field 排序，那么出来的顺序并不是按照拼音排序的，不是我们想要的结果。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="（1）方案一"><a href="#（1）方案一" class="headerlink" title="（1）方案一"></a>（1）方案一</h3><p>对于包含中文的字段加上”binary”属性，使之作为二进制比较，例如将”name char(10)”改成”name char(10)binary”。<br>如果使用源码编译MySQL，可以编译MySQL时使用 –with–charset=gbk 参数，这样MySQL就会直接支持中文查找和排序。也可以用 extra-charsets=gb2312,gbk 来加入多个字符集。</p>
<h3 id="（2）方案二"><a href="#（2）方案二" class="headerlink" title="（2）方案二"></a>（2）方案二</h3><p>可以在查询语句的order by部分使用 CONVERT 函数<br>对中文字段使用gbk编码排序：</p>
<blockquote>
<p>SELECT * FROM table ORDER BY CONVERT(chinese_field USING gbk );</p>
</blockquote>
<p>当然这需要你安装mysql时安装了gbk字符集，不然会报错：#1115 - Unknown character set: ‘gbk’</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>https://stefanma.github.io/2016/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是项目中的设计模式最普遍使用的模式之一。它是一种对象创建的模式，用于产生一个对象的具体实例，可以确保系统中一个类只产生一个实例。<br>有2大好处：<br>（1）对于频繁使用的对象，可以省略创建对象所花费的时间，对于那些重量级的对象而言，是一笔非常客观的系统开销；<br>（2）由于new的操作次数减少，因而对系统内存的使用频率也会降低，这将会减轻GC的压力，缩短GC停顿的时间；<br>对于系统的关键组件和被频繁使用的对象，使用单例可以有效的改善系统性能。</p>
<h3 id="单例类的角色："><a href="#单例类的角色：" class="headerlink" title="单例类的角色："></a>单例类的角色：</h3><table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单例者</td>
<td style="text-align:center">提供单例工厂，返回单例</td>
</tr>
<tr>
<td style="text-align:center">使用者</td>
<td style="text-align:center">获取并使用单例类</td>
</tr>
</tbody>
</table>
<h3 id="单例的实现："><a href="#单例的实现：" class="headerlink" title="单例的实现："></a>单例的实现：</h3><p>单例模式的核心是通过一个接口返回唯一的一个对象实例。一个简单的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Singleton is created.."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先单例类必须有一个private访问级别的构造函数，只有这样，才能保证单例不会被系统中其他代码内被实例化，这一点是相当重要的；其次instance成员变量和getInstance()方法必须是static的。<br>它唯一不足的地方是无法对instance做延迟加载。假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类的时候，单例对象会被创建，如果此时，这个单例类在系统中扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否被用到。</p>
<p>为了解决这个问题，并以此来提高系统在相关函数调用时的反应速度，就需要加入延迟加载机制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"LazySingleton is created.."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用上例中的单例实现，虽然实现了延迟加载的功能，但是和第一种方法相比，它引入了同步关键字，以此在多线程环境中，它的耗时会远远大于第一种的单例的实现。</p>
<p>为了使用延迟加载而引入同步关键字反而降低了系统性能，是不是有点得不偿失？<br>为了解决这个问题，对其进行改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"StaticSingleton is created.."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个实现中，单例模式使用内部类来维护单例的实例，当StaticSingleton被加载时，其内部类不会被初始化，故此可以确保StaticSingleton类被加载到JVM时，不会初始化单例类，而当getInstance()方法被调用时，才会加载SingletonHolder，从而初始化instance，同时，实例的创建是在类加载的时候完成的，故天生对多线程是友好的，getInstance()也不需要加同步关键字。这种方式兼顾以上两种实现的优点。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>使用内部类的方式实现单例，既可以做到延迟加载，也不必使用同步关键字，是一种比较完善的实现。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 设计优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式锁的基本原理]]></title>
      <url>https://stefanma.github.io/2016/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。分布式锁，是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往<strong>需要互斥来防止彼此干扰来保证一致性</strong>。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>1.假设有一个进程A，每小时准点给用户发送一条短信”Hello world”，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况。<br>2.假设部署在两台机器，那么问题来了，用户每个小时就会收到两条”Hello world”，信息就重复了<br>3.我们希望只发送一条”Hello world”，那么就可以引入分布式锁的概念了。<br>4.进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么就B就放弃此次任务，等待下一个小时。<br>5.问题的核心就在于怎么注册锁，检查锁的存在和注册锁是一个原子性操作，类似MySQL的主键，存在则不能insert，就说是你不能把我的锁覆盖了，你得等着。<br>6.我们有多种方式可以实现分布式锁，最简单的就是以每小时准点这个时间作为主键，到MySQL写入一条数据，利用数据库来维持一致性。</p>
<h2 id="针对分布式锁的实现，目前比较常用的有以下几种方案："><a href="#针对分布式锁的实现，目前比较常用的有以下几种方案：" class="headerlink" title="针对分布式锁的实现，目前比较常用的有以下几种方案："></a>针对分布式锁的实现，目前比较常用的有以下几种方案：</h2><p>1.基于数据库实现分布式锁<br>2.基于缓存（redis，memcached）实现分布式锁<br>3.基于Zookeeper实现分布式锁</p>
]]></content>
      
        <categories>
            
            <category> 分布式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[工作中一段SQL的优化]]></title>
      <url>https://stefanma.github.io/2016/05/07/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%B8%80%E6%AE%B5SQL%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="优化一段逻辑SQL"><a href="#优化一段逻辑SQL" class="headerlink" title="优化一段逻辑SQL"></a>优化一段逻辑SQL</h2><p>在工作中，在看到一段SQL语句很长，执行的效率比较慢，每个表都有好几百万数据，单查一个表差不多3秒左右，两个表union跑了将近20秒，需要进行优化。</p>
<p>原先的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> a.bondUniCode,a.bondShortName,<span class="keyword">SUM</span>(a.ofrPrice)<span class="keyword">AS</span> ofrPrice,<span class="keyword">SUM</span>(a.ofrVol)<span class="keyword">AS</span> ofrVol,<span class="keyword">SUM</span>(a.bidPrice)<span class="keyword">AS</span> bidPrice,<span class="keyword">SUM</span>(a.bidVol)<span class="keyword">AS</span> bidVol,a.sendTime </div><div class="line"><span class="keyword">FROM</span> ( </div><div class="line">	<span class="keyword">SELECT</span></div><div class="line">		t.bond_uni_code <span class="keyword">AS</span> bondUniCode, </div><div class="line">		t.bond_short_name <span class="keyword">AS</span> bondShortName, </div><div class="line">		<span class="number">0</span> <span class="keyword">AS</span> ofrPrice, </div><div class="line">		<span class="number">0</span> <span class="keyword">AS</span> ofrVol, </div><div class="line">		<span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.bond_price <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="number">0</span> <span class="keyword">ELSE</span> <span class="keyword">MAX</span>(t.bond_price) <span class="keyword">END</span> <span class="keyword">AS</span> bidPrice, </div><div class="line">		<span class="number">0</span> <span class="keyword">AS</span> bidVol, </div><div class="line">		<span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.send_time <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">''</span> <span class="keyword">ELSE</span> <span class="keyword">DATE_FORMAT</span>(t.send_time, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">END</span> <span class="keyword">AS</span> sendTime </div><div class="line">	<span class="keyword">FROM</span> dmdb.t_bond_quote t </div><div class="line">	<span class="keyword">WHERE</span> t.<span class="string">`status`</span> = <span class="number">1</span> <span class="keyword">AND</span> t.side = <span class="number">1</span> <span class="keyword">AND</span> t.bond_uni_code  <span class="number">0</span> <span class="keyword">AND</span> t.price_unit = <span class="number">2</span> <span class="keyword">AND</span> <span class="keyword">DATE_FORMAT</span>(t.send_time, <span class="string">'%Y-%m-%d'</span>)= <span class="string">'2016-04-10'</span></div><div class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> t.bond_uni_code  </div><div class="line">	<span class="keyword">UNION</span> </div><div class="line">	<span class="keyword">SELECT</span> </div><div class="line">		t.bond_uni_code <span class="keyword">AS</span> bondUniCode, </div><div class="line">		t.bond_short_name <span class="keyword">AS</span> bondShortName, </div><div class="line">		<span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.bond_price <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="number">0</span> <span class="keyword">ELSE</span> <span class="keyword">MIN</span>(t.bond_price) <span class="keyword">END</span> <span class="keyword">AS</span> ofrPrice, </div><div class="line">		<span class="number">0</span> <span class="keyword">AS</span> ofrVol, </div><div class="line">		<span class="number">0</span> <span class="keyword">AS</span> bidPrice, </div><div class="line">		<span class="number">0</span> <span class="keyword">AS</span> bidVol, </div><div class="line">		<span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.send_time <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">''</span> <span class="keyword">ELSE</span> <span class="keyword">DATE_FORMAT</span>(t.send_time, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">END</span> <span class="keyword">AS</span> sendTime </div><div class="line">	<span class="keyword">FROM</span> dmdb.t_bond_quote t </div><div class="line">	<span class="keyword">WHERE</span> t.<span class="string">`status`</span> = <span class="number">1</span> <span class="keyword">AND</span> t.side = <span class="number">2</span> <span class="keyword">AND</span> t.bond_uni_code  <span class="number">0</span> <span class="keyword">AND</span> t.price_unit = <span class="number">2</span> <span class="keyword">AND</span> <span class="keyword">DATE_FORMAT</span>(t.send_time, <span class="string">'%Y-%m-%d'</span>)= <span class="string">'2016-04-10'</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.bond_uni_code ) a <span class="keyword">GROUP</span> <span class="keyword">BY</span> a.bondUniCode;</div></pre></td></tr></table></figure></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>(1)观察这段SQL的逻辑主要是按照条件（查询条件相同，除了side不同外）查询最大和最小的price的值；<br>(2)查询条件中使用了DATE_FORMAT函数；<br>(3)使用了UNION做联合；</p>
<p>观察分析之后：</p>
<p><1>2段SQL是否可以写成一个SQL呢？毕竟是差不多的查询条件，或者可以在查询的结果中做min和max的筛选呢；</1></p>
<p><2>使用explain查看sql,在WHERE中使用DATE_FORMAT的send_time并没有使用到索引，使用该函数会使查询索引失效；</2></p>
<p><3>如果可以将逻辑合并一个SQL中，UNION就可以不用；</3></p>
<h2 id="优化后的SQL"><a href="#优化后的SQL" class="headerlink" title="优化后的SQL"></a>优化后的SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> t.bond_uni_code <span class="keyword">AS</span> bondUniCode,t.bond_short_name <span class="keyword">AS</span> bondShortName,</div><div class="line"><span class="keyword">MIN</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.bond_price <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> t.side = <span class="number">2</span> <span class="keyword">THEN</span> t.bond_price <span class="keyword">WHEN</span> t.bond_price <span class="keyword">IS</span> <span class="literal">NULL</span>  <span class="keyword">AND</span> t.side = <span class="number">2</span> <span class="keyword">THEN</span> <span class="number">0</span>  <span class="keyword">END</span>) <span class="keyword">AS</span> ofrPrice,</div><div class="line"><span class="number">0</span> <span class="keyword">AS</span> ofrVol, </div><div class="line"><span class="keyword">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.bond_price <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> t.side = <span class="number">1</span> <span class="keyword">THEN</span> t.bond_price <span class="keyword">WHEN</span> t.bond_price <span class="keyword">IS</span> <span class="literal">NULL</span>  <span class="keyword">AND</span> t.side = <span class="number">1</span> <span class="keyword">THEN</span>  <span class="number">0</span>  <span class="keyword">END</span>) <span class="keyword">AS</span> bidPrice,</div><div class="line"><span class="number">0</span> <span class="keyword">AS</span> bidVol,</div><div class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> t.send_time <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">''</span> <span class="keyword">ELSE</span> <span class="keyword">DATE_FORMAT</span>(t.send_time, <span class="string">'%Y-%m-%d'</span>) <span class="keyword">END</span> <span class="keyword">AS</span> sendTime </div><div class="line"><span class="keyword">FROM</span> dmdb.t_bond_quote t  </div><div class="line"><span class="keyword">WHERE</span> t.<span class="string">`status`</span> = <span class="number">1</span> <span class="keyword">AND</span> t.bond_uni_code  <span class="number">0</span> <span class="keyword">AND</span> t.price_unit = <span class="number">2</span> <span class="keyword">AND</span> t.send_time  <span class="keyword">BETWEEN</span> <span class="string">'2017-06-10 000000'</span> <span class="keyword">AND</span> <span class="string">'2016-04-10 235959'</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.bond_uni_code;</div></pre></td></tr></table></figure>
<p>优化后的SQL语句在相同的环境下执行效率提高了N倍，而且可以查询到与优化前的SQL的同样的结果。</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://stefanma.github.io/2016/05/03/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a> 
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
