<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stefan&#39;s Room</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stefanma.github.io/"/>
  <updated>2017-07-17T09:46:59.224Z</updated>
  <id>https://stefanma.github.io/</id>
  
  <author>
    <name>Stefan Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis性能问题排查解决手册</title>
    <link href="https://stefanma.github.io/2017/06/05/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%A7%A3%E5%86%B3%E6%89%8B%E5%86%8C/"/>
    <id>https://stefanma.github.io/2017/06/05/Redis性能问题排查解决手册/</id>
    <published>2017-06-05T07:27:26.000Z</published>
    <updated>2017-07-17T09:46:59.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据指标"><a href="#数据指标" class="headerlink" title="数据指标"></a>数据指标</h2><p>通过Redis-cli命令行界面访问到Redis服务器，然后使用info命令获取所有与Redis服务相关的信息。<br><img src="/img/redis_indicator_1.png" alt="示意图"></p>
<p>info命令输出的数据可分为10个类别，分别是：</p>
<ul>
<li>server</li>
<li>clients</li>
<li>memory</li>
<li>persistence</li>
<li>stats</li>
<li>replication</li>
<li>cpu</li>
<li>commandstats</li>
<li>cluster</li>
<li>keyspace</li>
</ul>
<h2 id="重要的两部分性能指标memory和stats"><a href="#重要的两部分性能指标memory和stats" class="headerlink" title="重要的两部分性能指标memory和stats"></a>重要的两部分性能指标memory和stats</h2><h3 id="性能指标memory"><a href="#性能指标memory" class="headerlink" title="性能指标memory"></a>性能指标memory</h3><p>可以指定info命令的参数来获取单个分类下的数据。输入info memory命令，会只返回与内存相关的数据。<br><img src="/img/redis_indicator_2.png" alt="示意图"></p>
<p>used_memory表示：由Redis分配器分配的内存总量，以字节（byte）为单位。<br>Redis使用的内存总量，它包含了实际缓存占用的内存和Redis自身运行所占用的内存(如元数据、lua)。它是由Redis使用内存分配器分配的内存，所以这个数据并没有把内存碎片浪费掉的内存给统计进去。</p>
<p>used_memory_human表示：该数据和used_memory是一样的值，它以M为单位显示，仅为了方便阅读。</p>
<p>used_memory_rss表示：从操作系统上显示已经分配的内存总量，以字节为单位。<br>mem_fragmentation_ratio表示：内存碎片率。<br>used_memory_lua表示：Lua脚本引擎所使用的内存大小。<br>mem_allocator表示：在编译时指定的Redis使用的内存分配器，可以是libc、jemalloc、tcmalloc。</p>
<h3 id="性能指标stats"><a href="#性能指标stats" class="headerlink" title="性能指标stats"></a>性能指标stats</h3><p><img src="/img/redis_indicator_4.png" alt="示意图"><br>在info信息里的total_commands_processed字段显示了Redis服务处理命令的总数，其命令都是从一个或多个Redis客户端请求过来的。Redis每时每刻都在处理从客户端请求过来的命令，它可以是Redis提供的140种命令的任意一个。total_commands_processed字段的值是递增的，比如Redis服务分别处理了client_x请求过来的2个命令和client_y请求过来的3个命令，那么命令处理总数(total_commands_processed)就会加上5。 </p>
<p>分析命令处理总数，诊断响应延迟。<br>在Redis实例中，跟踪命令处理总数是解决响应延迟问题最关键的部分，因为Redis是个单线程模型，客户端过来的命令是按照顺序执行的。比较常见的延迟是带宽，通过千兆网卡的延迟大约有200μs。倘若明显看到命令的响应时间变慢，延迟高于200μs，那可能是Redis命令队列里等待处理的命令数量比较多。如上所述，延迟时间增加导致响应时间变慢可能是由于一个或多个慢命令引起的，这时可以看到每秒命令处理数在明显下降，甚至于后面的命令完全被阻塞，导致Redis性能降低。要分析解决这个性能问题，需要跟踪命令处理数的数量和延迟时间。比如可以写个脚本，定期记录total_commands_processed的值。当客户端明显发现响应时间过慢时，可以通过记录的total_commands_processed历史数据值来判断命理处理总数是上升趋势还是下降趋势，以便排查问题。</p>
<h2 id="性能问题分析"><a href="#性能问题分析" class="headerlink" title="性能问题分析"></a>性能问题分析</h2><p>内存使用率是Redis服务最关键的一部分。如果一个Redis实例的内存使用率超过可用最大内存(used_memory &gt; 可用最大内存)，那么操作系统开始进行内存与swap空间交换，把内存中旧的或不再使用的内容写入硬盘上（硬盘上的这块空间叫Swap分区），以便腾出新的物理内存给新页或活动页(page)使用。在硬盘上进行读写操作要比在内存上进行读写操作，时间上慢了近5个数量级，内存是0.1μs单位、而硬盘是10ms。如果Redis进程上发生内存交换，那么Redis和依赖Redis上数据的应用会受到严重的性能影响。通过查看used_memory指标可知道Redis正在使用的内存情况，如果used_memory&gt;可用最大内存，那就说明Redis实例正在进行内存交换或者已经内存交换完毕。可以根据这个情况，执行相对应的应急措施。</p>
<h3 id="跟踪内存使用率"><a href="#跟踪内存使用率" class="headerlink" title="跟踪内存使用率"></a>跟踪内存使用率</h3><p>若是在使用Redis期间没有开启rdb快照或aof持久化策略，那么缓存数据在Redis崩溃时就有丢失的危险。因为当Redis内存使用率超过可用内存的95%时，部分数据开始在内存与swap空间来回交换，这时就可能有丢失数据的危险。<br>当开启并触发快照功能时，Redis会fork一个子进程把当前内存中的数据完全复制一份写入到硬盘上。因此若是当前使用内存超过可用内存的45%时触发快照功能，那么此时进行的内存交换会变的非常危险(可能会丢失数据)。倘若在这个时候实例上有大量频繁的更新操作，问题会变得更加严重。<br>通过减少Redis的内存占用率，来避免这样的问题：<br>（1）假如缓存数据小于4GB，就使用32位的Redis实例。因为32位实例上的指针大小只有64位的一半，它的内存空间占用空间会更少些。这有一个坏处就是，假设物理内存超过4GB，那么32位实例能使用的内存仍然会被限制在4GB以下。 要是实例同时也共享给其他一些应用使用的话，那可能需要更高效的64位Redis实例，这种情况下切换到32位是不可取的。 不管使用哪种方式，Redis的dump文件在32位和64位之间是互相兼容的， 因此倘若有减少占用内存空间的需求，可以尝试先使用32位，后面再切换到64位上。</p>
<p>（2）尽可能的使用Hash数据结构。因为Redis在储存小于100个字段的Hash结构上，其存储效率是非常高的。所以在不需要集合(set)操作或list的push/pop操作的时候，尽可能的使用Hash结构。比如，在一个web应用程序中，需要存储一个对象表示用户信息，使用单个key表示一个用户，其每个属性存储在Hash的字段里，这样要比给每个属性单独设置一个key-value要高效的多。通常情况下倘若有数据使用string结构，用多个key存储时，那么应该转换成单key多字段的Hash结构。如上述例子中介绍的Hash结构应包含，单个对象的属性或者单个用户各种各样的资料。Hash结构的操作命令是HSET(key, fields, value)和HGET(key, field)，使用它可以存储或从Hash中取出指定的字段。</p>
<p>（3）设置key的过期时间。一个减少内存使用率的简单方法就是，每当存储对象时确保设置key的过期时间。倘若key在明确的时间周期内使用或者旧key不大可能被使用时，就可以用Redis过期时间命令(expire,expireat,pexpire,pexpireat)去设置过期时间，这样Redis会在key过期时自动删除key。假如你知道每秒钟有多少个新key-value被创建，那可以调整key的存活时间，并指定阀值去限制Redis使用的最大内存。</p>
<p>（4）回收key。在Redis配置文件中(一般叫Redis.conf)，通过设置“maxmemory”属性的值可以限制Redis最大使用的内存，修改后重启实例生效。    也可以使用客户端命令config set maxmemory 去修改值，这个命令是立即生效的，但会在重启后会失效，需要使用config rewrite命令去刷新配置文件。若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销。 如果没开启快照功能，maxmemory最高能设置为系统可用内存的95%。</p>
<p>当内存使用达到设置的最大阀值时，需要选择一种key的回收策略，可在Redis.conf配置文件中修改“maxmemory-policy”属性值。 若是Redis数据集中的key都设置了过期时间，那么“volatile-ttl”策略是比较好的选择。但如果key在达到最大内存限制时没能够迅速过期，或者根本没有设置过期时间。那么设置为“allkeys-lru”值比较合适，它允许Redis从整个数据集中挑选最近最少使用的key进行删除(LRU淘汰算法)。<br>Redis还提供了一些其他淘汰策略：</p>
<ul>
<li>volatile-lru：使用LRU算法从已设置过期时间的数据集合中淘汰数据。</li>
<li>volatile-ttl：从已设置过期时间的数据集合中挑选即将过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集合中随机挑选数据淘汰。</li>
<li>allkeys-lru：使用LRU算法从所有数据集合中淘汰数据。</li>
<li>allkeys-random：从数据集合中任意选择数据淘汰</li>
<li>no-enviction：禁止淘汰数<br>通过设置maxmemory为系统可用内存的45%或95%(取决于持久化策略)和设置“maxmemory-policy”为“volatile-ttl”或“allkeys-lru”(取决于过期设置)，可以比较准确的限制Redis最大内存使用率，在绝大多数场景下使用这2种方式可确保Redis不会进行内存交换。</li>
</ul>
<h3 id="内存碎片率"><a href="#内存碎片率" class="headerlink" title="内存碎片率"></a>内存碎片率</h3><p>info信息中的mem_fragmentation_ratio给出了内存碎片率的数据指标，它是由操系统分配的内存除以Redis分配的内存得出的。<br><img src="/img/redis_indicator_3.png" alt="示意图"></p>
<p>used_memory_rss的rss是Resident Set Size的缩写，表示该进程所占物理内存的大小，是操作系统分配给Redis实例的内存大小。除了用户定义的数据和内部开销以外，used_memory_rss指标还包含了内存碎片的开销，内存碎片是由操作系统低效的分配/回收物理内存导致的。</p>
<p>操作系统负责分配物理内存给各个应用进程，Redis使用的内存与物理内存的映射是由操作系统上虚拟内存管理分配器完成的。例如：Redis需要分配连续内存块来存储1G的数据集，这样的话更有利，但可能物理内存上没有超过1G的连续内存块，那操作系统就不得不使用多个不连续的小内存块来分配并存储这1G数据，也就导致内存碎片的产生。内存分配器另一个复杂的层面是，它经常会预先分配一些内存块给引用，这样做会使加快应用程序的运行。</p>
<p>跟踪内存碎片率对理解Redis实例的资源性能是非常重要的。内存碎片率稍大于1是合理的，这个值表示内存碎片率比较低，也说明redis没有发生内存交换。但如果内存碎片率超过1.5，那就说明Redis消耗了实际需要物理内存的150%，其中50%是内存碎片率。若是内存碎片率低于1的话，说明Redis内存分配超出了物理内存，操作系统正在进行内存交换。</p>
<p>倘若内存碎片率超过了1.5，那可能是操作系统或Redis实例中内存管理变差的表现。有3种方法解决内存管理变差的问题，并提高Redis性能：<br>（1）重启Redis服务器：<br>如果内存碎片率超过1.5，重启Redis服务器可以让额外产生的内存碎片失效并重新作为新内存来使用，使操作系统恢复高效的内存管理。额外碎片的产生是由于Redis释放了内存块，但内存分配器并没有返回内存给操作系统，这个内存分配器是在编译时指定的，可以是libc、jemalloc或者tcmalloc。 通过比较used_memory_peak, used_memory_rss和used_memory_metrics的数据指标值可以检查额外内存碎片的占用。从名字上可以看出，used_memory_peak是过去Redis内存使用的峰值，而不是当前使用内存的值。如果used_memory_peak和used_memory_rss的值大致上相等，而且二者明显超过了used_memory值，这说明额外的内存碎片正在产生。<br>在重启服务器之前，需要在Redis-cli工具上输入shutdown save命令，意思是强制让Redis数据库执行保存操作并关闭Redis服务，这样做能保证在执行Redis关闭时不丢失任何数据。在重启后，Redis会从硬盘上加载持久化的文件，以确保数据集持续可用。</p>
<p>（2）限制内存交换：<br>如果内存碎片率低于1，Redis实例可能会把部分数据交换到硬盘上。内存交换会严重影响Redis的性能，所以应该增加可用物理内存或减少实Redis内存占用。</p>
<p>（3）修改内存分配器：<br>Redis支持glibc’s    malloc、jemalloc11、tcmalloc几种不同的内存分配器，每个分配器在内存分配和碎片上都有不同的实现。不建议普通管理员修改Redis默认内存分配器，因为这需要完全理解这几种内存分配器的差异，也要重新编译Redis。这个方法更多的是让其了解Redis内存分配器所做的工作，当然也是改善内存碎片问题的一种办法。</p>
<h3 id="响应延迟"><a href="#响应延迟" class="headerlink" title="响应延迟"></a>响应延迟</h3><p>使用命令处理总数解决延迟时间增加。<br>通过与记录的历史数据比较得知，命令处理总数确实是处于上升或下降状态，那么可能是有2个原因引起的:<br>1.命令队列里的命令数量过多，后面命令一直在等待中。<br>2.几个慢命令阻塞Redis。</p>
<p>下面有三个办法可以解决，因上面两条原因引起的响应延迟问题。<br>（1）使用多参数命令<br>若是客户端在很短的时间内发送大量的命令过来，会发现响应时间明显变慢，这由于后面命令一直在等待队列中前面大量命令执行完毕。有个方法可以改善延迟问题，就是通过单命令多参数的形式取代多命令单参数的形式。举例来说，循环使用LSET命令去添加1000个元素到list结构中，是性能比较差的一种方式，更好的做法是在客户端创建一个1000元素的列表，用单个命令LPUSH或RPUSH，通过多参数构造形式一次性把1000个元素发送的Redis服务上。</p>
<p>（2）管道命令<br>另一个减少多命令的方法是使用管道(pipeline)，把几个命令合并一起执行，从而减少因网络开销引起的延迟问题。因为10个命令单独发送到服务端会引起10次网络延迟开销，使用管道会一次性把执行结果返回，仅需要一次网络延迟开销。Redis本身支持管道命令，大多数客户端也支持，倘若当前实例延迟很明显，那么使用管道去降低延迟是非常有效的。</p>
<p>（3）避免操作大集合的慢命令<br>如果命令处理频率过低导致延迟时间增加，这可能是因为使用了高时间复杂度的命令操作导致，这意味着每个命令从集合中获取数据的时间增大。 所以减少使用高时间复杂的命令，能显著的提高的Redis的性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于开发者来说，Redis是个速度非常快的key-value内存数据库，并提供了方便的API接口。为了最好最优的使用Redis，需要理解哪些因素能影响到Redis性能，哪些数据指标能帮助我们避免性能陷阱。能理解Redis中的重要性能指标，怎么查看，更重要的是怎么利用这些数据排查解决Redis性能问题。</p>
<blockquote>
<p>主要的URL：<br><a href="https://www.datadoghq.com/pdf/Understanding-the-Top-5-Redis-Performance-Metrics.pdf" target="_blank" rel="external">https://www.datadoghq.com/pdf/Understanding-the-Top-5-Redis-Performance-Metrics.pdf</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      监控和查看Redis，排查可能会遇到的Redis性能问题
    
    </summary>
    
      <category term="Redis" scheme="https://stefanma.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://stefanma.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis的数据淘汰</title>
    <link href="https://stefanma.github.io/2017/06/03/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0/"/>
    <id>https://stefanma.github.io/2017/06/03/Redis的数据淘汰/</id>
    <published>2017-06-03T03:27:26.000Z</published>
    <updated>2017-07-07T07:36:59.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Redis中，允许用户设置最大使用内存大小server.maxmemory，在内存限定的情况下是很有用的。例如：在一台8G服务器上部署了4个redis服务点，每一个服务点分配 2G的内存大小，减少内存紧张的情况，由此获取更为稳健的服务。</p>
<p>当Redis被当做缓存来使用，当你新增数据时，让它自动地回收旧数据是件很方便的事情。LRU是Redis唯一支持的回收方法。Redis的maxmemory指令用于将可用内存限制成一个固定大小，还包括了Redis使用的LRU(Least Recently Used)算法，这个实际上只是近似的LRU。</p>
<p>Redis中当内存超过限制时，按照配置的策略，淘汰掉相应的键值对数据，使得内存可以继续留有足够的空间保存新的数据。</p>
<p>redis.conf文件中有对该机制的一份很好的解释:<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># Don't use more memory than the specified amount of bytes.</div><div class="line"># When the memory limit is reached Redis will try to remove keys</div><div class="line"># according to the eviction policy selected (see maxmemory-policy).</div><div class="line">#</div><div class="line"># If Redis can't remove keys according to the policy, or if the policy is</div><div class="line"># set to 'noeviction', Redis will start to reply with errors to commands</div><div class="line"># that would use more memory, like SET, LPUSH, and so on, and will continue</div><div class="line"># to reply to read-only commands like GET.</div><div class="line">#</div><div class="line"># This option is usually useful when using Redis as an LRU cache, or to set</div><div class="line"># a hard memory limit for an instance (using the 'noeviction' policy).</div><div class="line">#</div><div class="line"># WARNING: If you have slaves attached to an instance with maxmemory on,</div><div class="line"># the size of the output buffers needed to feed the slaves are subtracted</div><div class="line"># from the used memory count, so that network problems / resyncs will</div><div class="line"># not trigger a loop where keys are evicted, and in turn the output</div><div class="line"># buffer of slaves is full with DELs of keys evicted triggering the deletion</div><div class="line"># of more keys, and so forth until the database is completely emptied.</div><div class="line">#</div><div class="line"># In short... if you have slaves attached it is suggested that you set a lower</div><div class="line"># limit for maxmemory so that there is some free RAM on the system for slave</div><div class="line"># output buffers (but this is not needed if the policy is 'noeviction').</div><div class="line">#</div><div class="line"># maxmemory &lt;bytes&gt;</div></pre></td></tr></table></figure></p>
<h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><p>Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。<br><img src="/img/redis_lru_1.png" alt="示意图"><br>Redis提供6种数据淘汰策略：<br>(1)volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰;<br>(2)volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰;<br>(3)volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰;<br>(4)allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰;<br>(5)allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰;<br>(6)noeviction（驱逐）：禁止驱逐数据;</p>
<p>选择正确的回收策略是非常重要的，取决于应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。<br>一般的经验规则:<br>使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。.<br>使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。<br>使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。<br>allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。<br>为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。</p>
<h2 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h2><p>回收进程如何工作的:<br>1.一个客户端运行了新的命令，添加了新的数据。<br>2.Redis检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。<br>3.一个新的命令被执行，等等。<br>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。<br>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p>
<h2 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h2><h3 id="LRU数据淘汰机制"><a href="#LRU数据淘汰机制" class="headerlink" title="LRU数据淘汰机制"></a>LRU数据淘汰机制</h3><p>在服务器配置中保存了lru计数器 server.lrulock，会定时（redis 定时程序serverCorn()）更新，server.lrulock 的值是根据server.unixtime计算出来。<br>另外，从struct redisObject中可以发现，每一个redis对象都会设置相应的lru。可以想象的是，每一次访问数据的时候，会更新 redisObject.lru。<br>LRU数据淘汰机制：在数据集中随机挑选几个键值对，取出其中lru最大的键值对淘汰。所以redis并不是保证取得所有数据集中最近最少使用（LRU）的键值对，而只是随机挑选的几个键值对中的。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">// redisServer 保存了 lru 计数器</div><div class="line">struct redisServer &#123;</div><div class="line">    ...</div><div class="line">    unsigned lruclock:22;       /* Clock incrementing every minute, for LRU */</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 每一个 redis 对象都保存了 lru</div><div class="line">#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;21)-1) /* Max value of obj-&gt;lru */</div><div class="line">#define REDIS_LRU_CLOCK_RESOLUTION 10 /* LRU clock resolution in seconds */</div><div class="line">typedef struct redisObject &#123;</div><div class="line">    // 刚刚好 32 bits</div><div class="line"></div><div class="line">    // 对象的类型，字符串/列表/集合/哈希表</div><div class="line">    unsigned type:4;</div><div class="line">    // 未使用的两个位</div><div class="line">    unsigned notused:2;     /* Not used */</div><div class="line">    // 编码的方式，redis 为了节省空间，提供多种方式来保存一个数据</div><div class="line">    // 譬如：“123456789” 会被存储为整数 123456789</div><div class="line">    unsigned encoding:4;</div><div class="line">    unsigned lru:22;        /* lru time (relative to server.lruclock) */</div><div class="line">    // 引用数</div><div class="line">    int refcount;</div><div class="line"></div><div class="line">    // 数据指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div><div class="line"></div><div class="line">// redis 定时执行程序。联想：linux cron</div><div class="line">int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) &#123;</div><div class="line">    ......</div><div class="line">    /* We have just 22 bits per object for LRU information.</div><div class="line">     * So we use an (eventually wrapping) LRU clock with 10 seconds resolution.</div><div class="line">     * 2^22 bits with 10 seconds resolution is more or less 1.5 years.</div><div class="line">     *</div><div class="line">     * Note that even if this will wrap after 1.5 years it's not a problem,</div><div class="line">     * everything will still work but just some object will appear younger</div><div class="line">     * to Redis. But for this to happen a given object should never be touched</div><div class="line">     * for 1.5 years.</div><div class="line">     *</div><div class="line">     * Note that you can change the resolution altering the</div><div class="line">     * REDIS_LRU_CLOCK_RESOLUTION define.</div><div class="line">     */</div><div class="line">    updateLRUClock();</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 更新服务器的 lru 计数器</div><div class="line">void updateLRUClock(void) &#123;</div><div class="line">    server.lruclock = (server.unixtime/REDIS_LRU_CLOCK_RESOLUTION) &amp;</div><div class="line">                                                REDIS_LRU_CLOCK_MAX;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="TTL数据淘汰机制"><a href="#TTL数据淘汰机制" class="headerlink" title="TTL数据淘汰机制"></a>TTL数据淘汰机制</h3><p>Redis数据集数据结构中保存了键值对过期时间的表，即redisDb.expires。和LRU数据淘汰机制类似。<br>TTL数据淘汰机制：从过期时间的表中随机挑选几个键值对，取出其中ttl最大的键值对淘汰。同样，redis并不是保证取得所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对中的。</p>
<p>另外，redis每服务客户端执行一个命令的时候，会检测使用的内存是否超额。如果超额，即进行数据淘汰。<br>相关Redis代码：<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line">// 执行命令</div><div class="line">int processCommand(redisClient *c) &#123;</div><div class="line">    ......</div><div class="line">    // 内存超额</div><div class="line">    /* Handle the maxmemory directive.</div><div class="line">     *</div><div class="line">     * First we try to free some memory if possible (if there are volatile</div><div class="line">     * keys in the dataset). If there are not the only thing we can do</div><div class="line">     * is returning an error. */</div><div class="line">    if (server.maxmemory) &#123;</div><div class="line">        int retval = freeMemoryIfNeeded();</div><div class="line">        if ((c-&gt;cmd-&gt;flags &amp; REDIS_CMD_DENYOOM) &amp;&amp; retval == REDIS_ERR) &#123;</div><div class="line">            flagTransaction(c);</div><div class="line">            addReply(c, shared.oomerr);</div><div class="line">            return REDIS_OK;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果需要，是否一些内存</div><div class="line">int freeMemoryIfNeeded(void) &#123;</div><div class="line">    size_t mem_used, mem_tofree, mem_freed;</div><div class="line">    int slaves = listLength(server.slaves);</div><div class="line"></div><div class="line">    // redis 从机回复空间和 AOF 内存大小不计算入 redis 内存大小</div><div class="line">    /* Remove the size of slaves output buffers and AOF buffer from the</div><div class="line">     * count of used memory. */</div><div class="line">    mem_used = zmalloc_used_memory();</div><div class="line"></div><div class="line">    // 从机回复空间大小</div><div class="line">    if (slaves) &#123;</div><div class="line">        listIter li;</div><div class="line">        listNode *ln;</div><div class="line"></div><div class="line">        listRewind(server.slaves,&amp;li);</div><div class="line">        while((ln = listNext(&amp;li))) &#123;</div><div class="line">            redisClient *slave = listNodeValue(ln);</div><div class="line">            unsigned long obuf_bytes = getClientOutputBufferMemoryUsage(slave);</div><div class="line">            if (obuf_bytes &gt; mem_used)</div><div class="line">                mem_used = 0;</div><div class="line">            else</div><div class="line">                mem_used -= obuf_bytes;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // server.aof_buf &amp;&amp; server.aof_rewrite_buf_blocks</div><div class="line">    if (server.aof_state != REDIS_AOF_OFF) &#123;</div><div class="line">        mem_used -= sdslen(server.aof_buf);</div><div class="line">        mem_used -= aofRewriteBufferSize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 内存是否超过设置大小</div><div class="line">    /* Check if we are over the memory limit. */</div><div class="line">    if (mem_used &lt;= server.maxmemory) return REDIS_OK;</div><div class="line"></div><div class="line">    // redis 中可以设置内存超额策略</div><div class="line">    if (server.maxmemory_policy == REDIS_MAXMEMORY_NO_EVICTION)</div><div class="line">        return REDIS_ERR; /* We need to free memory, but policy forbids. */</div><div class="line"></div><div class="line">    /* Compute how much memory we need to free. */</div><div class="line">    mem_tofree = mem_used - server.maxmemory;</div><div class="line">    mem_freed = 0;</div><div class="line">    while (mem_freed &lt; mem_tofree) &#123;</div><div class="line">        int j, k, keys_freed = 0;</div><div class="line"></div><div class="line">        // 遍历所有数据集</div><div class="line">        for (j = 0; j &lt; server.dbnum; j++) &#123;</div><div class="line">            long bestval = 0; /* just to prevent warning */</div><div class="line">            sds bestkey = NULL;</div><div class="line">            struct dictEntry *de;</div><div class="line">            redisDb *db = server.db+j;</div><div class="line">            dict *dict;</div><div class="line"></div><div class="line">            // 不同的策略，选择的数据集不一样</div><div class="line">            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM)</div><div class="line">            &#123;</div><div class="line">                dict = server.db[j].dict;</div><div class="line">            &#125; else &#123;</div><div class="line">                dict = server.db[j].expires;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 数据集为空，继续下一个数据集</div><div class="line">            if (dictSize(dict) == 0) continue;</div><div class="line"></div><div class="line">            // 随机淘汰随机策略：随机挑选</div><div class="line">            /* volatile-random and allkeys-random policy */</div><div class="line">            if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_RANDOM ||</div><div class="line">                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_RANDOM)</div><div class="line">            &#123;</div><div class="line">                de = dictGetRandomKey(dict);</div><div class="line">                bestkey = dictGetKey(de);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // LRU 策略：挑选最近最少使用的数据</div><div class="line">            /* volatile-lru and allkeys-lru policy */</div><div class="line">            else if (server.maxmemory_policy == REDIS_MAXMEMORY_ALLKEYS_LRU ||</div><div class="line">                server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)</div><div class="line">            &#123;</div><div class="line">                // server.maxmemory_samples 为随机挑选键值对次数</div><div class="line">                // 随机挑选 server.maxmemory_samples个键值对，驱逐最近最少使用的数据</div><div class="line">                for (k = 0; k &lt; server.maxmemory_samples; k++) &#123;</div><div class="line">                    sds thiskey;</div><div class="line">                    long thisval;</div><div class="line">                    robj *o;</div><div class="line"></div><div class="line">                    // 随机挑选键值对</div><div class="line">                    de = dictGetRandomKey(dict);</div><div class="line"></div><div class="line">                    // 获取键</div><div class="line">                    thiskey = dictGetKey(de);</div><div class="line"></div><div class="line">                    /* When policy is volatile-lru we need an additional lookup</div><div class="line">                     * to locate the real key, as dict is set to db-&gt;expires. */</div><div class="line">                    if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_LRU)</div><div class="line">                        de = dictFind(db-&gt;dict, thiskey);</div><div class="line">                    o = dictGetVal(de);</div><div class="line"></div><div class="line">                    // 计算数据的空闲时间</div><div class="line">                    thisval = estimateObjectIdleTime(o);</div><div class="line"></div><div class="line">                    // 当前键值空闲时间更长，则记录</div><div class="line">                    /* Higher idle time is better candidate for deletion */</div><div class="line">                    if (bestkey == NULL || thisval &gt; bestval) &#123;</div><div class="line">                        bestkey = thiskey;</div><div class="line">                        bestval = thisval;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // TTL 策略：挑选将要过期的数据</div><div class="line">            /* volatile-ttl */</div><div class="line">            else if (server.maxmemory_policy == REDIS_MAXMEMORY_VOLATILE_TTL) &#123;</div><div class="line">                // server.maxmemory_samples 为随机挑选键值对次数</div><div class="line">                // 随机挑选 server.maxmemory_samples个键值对，驱逐最快要过期的数据</div><div class="line">                for (k = 0; k &lt; server.maxmemory_samples; k++) &#123;</div><div class="line">                    sds thiskey;</div><div class="line">                    long thisval;</div><div class="line"></div><div class="line">                    de = dictGetRandomKey(dict);</div><div class="line">                    thiskey = dictGetKey(de);</div><div class="line">                    thisval = (long) dictGetVal(de);</div><div class="line"></div><div class="line">                    /* Expire sooner (minor expire unix timestamp) is better</div><div class="line">                     * candidate for deletion */</div><div class="line">                    if (bestkey == NULL || thisval &lt; bestval) &#123;</div><div class="line">                        bestkey = thiskey;</div><div class="line">                        bestval = thisval;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 删除选定的键值对</div><div class="line">            /* Finally remove the selected key. */</div><div class="line">            if (bestkey) &#123;</div><div class="line">                long long delta;</div><div class="line"></div><div class="line">                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</div><div class="line"></div><div class="line">                // 发布数据更新消息，主要是 AOF 持久化和从机</div><div class="line">                propagateExpire(db,keyobj);</div><div class="line"></div><div class="line">                // 注意， propagateExpire() 可能会导致内存的分配， propagateExpire() 提前执行就是因为 redis 只计算 dbDelete() 释放的内存大小。倘若同时计算 dbDelete() 释放的内存和 propagateExpire() 分配空间的大小，与此同时假设分配空间大于释放空间，就有可能永远退不出这个循环。</div><div class="line">                // 下面的代码会同时计算 dbDelete() 释放的内存和 propagateExpire() 分配空间的大小：</div><div class="line">                // propagateExpire(db,keyobj);</div><div class="line">                // delta = (long long) zmalloc_used_memory();</div><div class="line">                // dbDelete(db,keyobj);</div><div class="line">                // delta -= (long long) zmalloc_used_memory();</div><div class="line">                // mem_freed += delta;</div><div class="line">                /////////////////////////////////////////</div><div class="line"></div><div class="line">                /* We compute the amount of memory freed by dbDelete() alone.</div><div class="line">                 * It is possible that actually the memory needed to propagate</div><div class="line">                 * the DEL in AOF and replication link is greater than the one</div><div class="line">                 * we are freeing removing the key, but we can't account for</div><div class="line">                 * that otherwise we would never exit the loop.</div><div class="line">                 *</div><div class="line">                 * AOF and Output buffer memory will be freed eventually so</div><div class="line">                 * we only care about memory used by the key space. */</div><div class="line">                // 只计算 dbDelete() 释放内存的大小</div><div class="line">                delta = (long long) zmalloc_used_memory();</div><div class="line">                dbDelete(db,keyobj);</div><div class="line">                delta -= (long long) zmalloc_used_memory();</div><div class="line">                mem_freed += delta;</div><div class="line"></div><div class="line">                server.stat_evictedkeys++;</div><div class="line"></div><div class="line">                // 将数据的删除通知所有的订阅客户端</div><div class="line">                notifyKeyspaceEvent(REDIS_NOTIFY_EVICTED, "evicted",</div><div class="line">                    keyobj, db-&gt;id);</div><div class="line">                decrRefCount(keyobj);</div><div class="line">                keys_freed++;</div><div class="line"></div><div class="line">                // 将从机回复空间中的数据及时发送给从机</div><div class="line">                /* When the memory to free starts to be big enough, we may</div><div class="line">                 * start spending so much time here that is impossible to</div><div class="line">                 * deliver data to the slaves fast enough, so we force the</div><div class="line">                 * transmission here inside the loop. */</div><div class="line">                if (slaves) flushSlavesOutputBuffers();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 未能释放空间，且此时 redis 使用的内存大小依旧超额，失败返回</div><div class="line">        if (!keys_freed) return REDIS_ERR; /* nothing to free... */</div><div class="line">    &#125;</div><div class="line">    return REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>官方说明地址：<a href="https://redis.io/topics/lru-cache" target="_blank" rel="external">https://redis.io/topics/lru-cache</a></p>
]]></content>
    
    <summary type="html">
    
      应对某些场景可以将Redis当做LRU缓存来使用
    
    </summary>
    
      <category term="Redis" scheme="https://stefanma.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://stefanma.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>可供参考的Spring集成Redis的方式</title>
    <link href="https://stefanma.github.io/2017/06/02/%E5%8F%AF%E4%BE%9B%E5%8F%82%E8%80%83%E7%9A%84Spring%E9%9B%86%E6%88%90Redis%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://stefanma.github.io/2017/06/02/可供参考的Spring集成Redis的方式/</id>
    <published>2017-06-02T04:16:19.000Z</published>
    <updated>2017-07-06T03:34:35.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h2><p>配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 加载配置属性文件 --&gt;    </div><div class="line">&lt;context:property-placeholder ignore-unresolvable="true" location="classpath:redis.properties" /&gt;     </div><div class="line">    </div><div class="line">&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;    </div><div class="line">    &lt;property name="maxIdle" value="300" /&gt; &lt;!-- 最大能够保持idel状态的对象数 --&gt;     </div><div class="line">    &lt;property name="maxTotal" value="60000" /&gt; &lt;!-- 最大分配的对象数 --&gt;    </div><div class="line">    &lt;property name="testOnBorrow" value="true" /&gt; &lt;!-- 当调用borrow Object方法时，是否进行有效性检查 --&gt;    </div><div class="line">&lt;/bean&gt;    </div><div class="line">    </div><div class="line">&lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt;    </div><div class="line">    &lt;constructor-arg index="0" ref="jedisPoolConfig" /&gt;    </div><div class="line">    &lt;constructor-arg index="1" value="$&#123;redis.host&#125;" /&gt;    </div><div class="line">    &lt;constructor-arg index="2" value="$&#123;redis.port&#125;" type="int" /&gt;    </div><div class="line">    &lt;constructor-arg index="3" value="$&#123;redis.timeout&#125;"/&gt;    </div><div class="line">    &lt;constructor-arg index="4" value="$&#123;redis.password&#125;"/&gt;    </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Sentinel哨兵模式"><a href="#Sentinel哨兵模式" class="headerlink" title="Sentinel哨兵模式"></a>Sentinel哨兵模式</h2><p>redis.properties内容<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">##sentinel1的IP和端口  </div><div class="line">redis.sentinel1.host=192.168.1.55  </div><div class="line">redis.sentinel1.port=26379  </div><div class="line">##sentinel2的IP和端口    </div><div class="line">redis.sentinel2.host=192.168.1.56  </div><div class="line">redis.sentinel2.port=26380  </div><div class="line">redis.password=abc@123$321  </div><div class="line">  </div><div class="line">#最大闲置连接数    </div><div class="line">redis.maxIdle=50  </div><div class="line">#最大连接数，超过此连接时操作redis会报错    </div><div class="line">redis.maxTotal=200  </div><div class="line">redis.maxWaitTime=3000   </div><div class="line">redis.testOnBorrow=true  </div><div class="line">#最小闲置连接数，spring启动的时候自动建立该数目的连接供应用程序使用，不够的时候会申请。    </div><div class="line">redis.minIdle=30</div></pre></td></tr></table></figure></p>
<p>配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;context:property-placeholder ignore-unresolvable="true" location="classpath:redis.properties" /&gt;  </div><div class="line">    &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;  </div><div class="line">        &lt;property name="maxTotal" value="$&#123;redis.maxTotal&#125;" /&gt;  </div><div class="line">        &lt;property name="minIdle" value="$&#123;redis.minIdle&#125;" /&gt;  </div><div class="line">        &lt;property name="maxWaitMillis" value="$&#123;redis.maxWaitTime&#125;" /&gt;  </div><div class="line">        &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt;  </div><div class="line">        &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt;  </div><div class="line">        &lt;property name="testOnReturn" value="true" /&gt;  </div><div class="line">        &lt;property name="testWhileIdle" value="true" /&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">    &lt;bean id="jedisSentinelPool" class="redis.clients.jedis.JedisSentinelPool"&gt;  </div><div class="line">        &lt;constructor-arg index="0" value="mymaster" /&gt;  </div><div class="line">        &lt;constructor-arg index="1"&gt;  </div><div class="line">            &lt;set&gt;  </div><div class="line">                &lt;value&gt;$&#123;redis.sentinel1.host&#125;:$&#123;redis.sentinel1.port&#125;&lt;/value&gt;  </div><div class="line">                &lt;value&gt;$&#123;redis.sentinel2.host&#125;:$&#123;redis.sentinel2.port&#125;&lt;/value&gt;  </div><div class="line">            &lt;/set&gt;  </div><div class="line">        &lt;/constructor-arg&gt;  </div><div class="line">        &lt;constructor-arg index="2" ref="poolConfig" /&gt;   </div><div class="line">        &lt;constructor-arg index="3" value="$&#123;redis.password&#125;" /&gt;  </div><div class="line">    &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Redis-Cluster集群模式"><a href="#Redis-Cluster集群模式" class="headerlink" title="Redis Cluster集群模式"></a>Redis Cluster集群模式</h2><p>配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;!-- Jedis链接池配置，Jedis版本建议升级到最新 --&gt;    </div><div class="line">    &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;    </div><div class="line">        &lt;property name="maxTotal" value="100" /&gt;    </div><div class="line">        &lt;property name="maxIdle" value="20" /&gt;    </div><div class="line">        &lt;property name="minIdle" value="10" /&gt;    </div><div class="line">        &lt;property name="blockWhenExhausted" value="true"&gt;&lt;/property&gt;    </div><div class="line">        &lt;property name="maxWaitMillis" value="3000" /&gt;    </div><div class="line">        &lt;property name="testOnBorrow" value="false" /&gt;    </div><div class="line">        &lt;property name="testOnReturn" value="false" /&gt;    </div><div class="line">        &lt;property name="testWhileIdle" value="true" /&gt;    </div><div class="line">        &lt;property name="minEvictableIdleTimeMillis" value="60000" /&gt;    </div><div class="line">        &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt;    </div><div class="line">        &lt;property name="numTestsPerEvictionRun" value="-1" /&gt;    </div><div class="line">    &lt;/bean&gt;    </div><div class="line">    </div><div class="line">    &lt;!-- JedisCluster --&gt;    </div><div class="line">    &lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt;    </div><div class="line">        &lt;constructor-arg index="0"&gt;    </div><div class="line">            &lt;set&gt;    </div><div class="line">                &lt;bean class="redis.clients.jedis.HostAndPort"&gt;    </div><div class="line">                    &lt;constructor-arg index="0" value="192.168.1.111" /&gt;    </div><div class="line">                    &lt;constructor-arg index="1" value="7111" type="int" /&gt;    </div><div class="line">                &lt;/bean&gt;    </div><div class="line">                &lt;bean class="redis.clients.jedis.HostAndPort"&gt;    </div><div class="line">                    &lt;constructor-arg index="0" value="192.168.1.112" /&gt;    </div><div class="line">                    &lt;constructor-arg index="1" value="7112" type="int" /&gt;    </div><div class="line">                &lt;/bean&gt;    </div><div class="line">                &lt;bean class="redis.clients.jedis.HostAndPort"&gt;    </div><div class="line">                    &lt;constructor-arg index="0" value="192.168.1.113" /&gt;    </div><div class="line">                    &lt;constructor-arg index="1" value="7113" type="int" /&gt;    </div><div class="line">                &lt;/bean&gt;    </div><div class="line">                &lt;bean class="redis.clients.jedis.HostAndPort"&gt;    </div><div class="line">                    &lt;constructor-arg index="0" value="192.168.1.114" /&gt;    </div><div class="line">                    &lt;constructor-arg index="1" value="7114" type="int" /&gt;    </div><div class="line">                &lt;/bean&gt;    </div><div class="line">                &lt;bean class="redis.clients.jedis.HostAndPort"&gt;    </div><div class="line">                    &lt;constructor-arg index="0" value="192.168.1.115" /&gt;    </div><div class="line">                    &lt;constructor-arg index="1" value="7115" type="int" /&gt;    </div><div class="line">                &lt;/bean&gt;    </div><div class="line">                &lt;bean class="redis.clients.jedis.HostAndPort"&gt;    </div><div class="line">                    &lt;constructor-arg index="0" value="192.168.1.116" /&gt;    </div><div class="line">                    &lt;constructor-arg index="1" value="7116" type="int" /&gt;    </div><div class="line">                &lt;/bean&gt;    </div><div class="line">            &lt;/set&gt;    </div><div class="line">        &lt;/constructor-arg&gt;    </div><div class="line">        &lt;constructor-arg index="1" value="2000" type="int"&gt;&lt;/constructor-arg&gt;    </div><div class="line">        &lt;constructor-arg index="2" value="100" type="int"&gt;&lt;/constructor-arg&gt;    </div><div class="line">        &lt;constructor-arg index="3" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt;    </div><div class="line">    &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Redis-Sharding集群模式"><a href="#Redis-Sharding集群模式" class="headerlink" title="Redis Sharding集群模式"></a>Redis Sharding集群模式</h2><p>配置文件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;!-- jedis 连接池配置--&gt;  </div><div class="line">    &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;    </div><div class="line">        &lt;property name="maxActive"     value="$&#123;redis.pool.maxActive&#125;" /&gt;    </div><div class="line">        &lt;property name="maxIdle"       value="$&#123;redis.pool.maxIdle&#125;" /&gt;    </div><div class="line">        &lt;property name="maxWait"       value="$&#123;redis.pool.maxWait&#125;" /&gt;    </div><div class="line">        &lt;property name="testOnBorrow"  value="$&#123;redis.pool.testOnBorrow&#125;" /&gt;    </div><div class="line">    &lt;/bean&gt;    </div><div class="line">      &lt;!-- jedis 多个服务器配置--&gt;  </div><div class="line">      &lt;bean id="jedisShardInfo1" class="redis.clients.jedis.JedisShardInfo"&gt;    </div><div class="line">        &lt;constructor-arg index="0" value="$&#123;redis2.ip&#125;" /&gt;    </div><div class="line">        &lt;constructor-arg index="1" value="$&#123;redis.port&#125;" type="int" /&gt;  </div><div class="line">        &lt;property value="$&#123;redis.password&#125;" name="password"/&gt;       </div><div class="line">      &lt;/bean&gt;   </div><div class="line">    </div><div class="line">      &lt;bean id="jedisShardInfo2" class="redis.clients.jedis.JedisShardInfo"&gt;    </div><div class="line">        &lt;constructor-arg index="0" value="$&#123;redis.ip&#125;" /&gt;    </div><div class="line">        &lt;constructor-arg index="1" value="$&#123;redis.port&#125;" type="int" /&gt;  </div><div class="line">        &lt;property value="$&#123;redis.password&#125;" name="password"/&gt;     </div><div class="line">      &lt;/bean&gt;   </div><div class="line">    </div><div class="line">      &lt;bean id="shardedJedisPool" class="redis.clients.jedis.ShardedJedisPool"&gt;    </div><div class="line">        &lt;constructor-arg index="0" ref="jedisPoolConfig" /&gt;    </div><div class="line">        &lt;constructor-arg index="1"&gt;  </div><div class="line">          &lt;list&gt;  </div><div class="line">            &lt;ref bean="jedisShardInfo1" /&gt;  </div><div class="line">            &lt;ref bean="jedisShardInfo2"/&gt;  </div><div class="line">          &lt;/list&gt;  </div><div class="line">        &lt;/constructor-arg&gt;    </div><div class="line">      &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      提供一些项目中可能需要用到的可供参考的Spring集成Redis的配置文件方式。
    
    </summary>
    
      <category term="Redis" scheme="https://stefanma.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://stefanma.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>低成本高可用Redis集群解决方案设计</title>
    <link href="https://stefanma.github.io/2017/05/30/%E4%BD%8E%E6%88%90%E6%9C%AC%E9%AB%98%E5%8F%AF%E7%94%A8Redis%E9%9B%86%E7%BE%A4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/"/>
    <id>https://stefanma.github.io/2017/05/30/低成本高可用Redis集群解决方案设计/</id>
    <published>2017-05-30T07:03:45.000Z</published>
    <updated>2017-07-06T04:05:19.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis高可用方案，看到较多的是Keepalived、Zookeeper方案。Keepalived是主备模式，意味着总有一台浪费着，Keepalived方案配置简单、人力成本小，在数据量少、压力小的情况下推荐使用。Zookeeper工作量成本偏高。可以利用Redis提供的特性，构建低成本高可用的Redis集群。</p>
<h2 id="Redis-Sentinel（哨兵）"><a href="#Redis-Sentinel（哨兵）" class="headerlink" title="Redis Sentinel（哨兵）"></a>Redis Sentinel（哨兵）</h2><p>Sentinel是Redis官方为集群提供的高可用解决方案。在实际项目中可以使用sentinel去做redis自动故障转移，减少人工介入的工作量。另外sentinel也给客户端提供了监控消息的通知，这样客户端就可根据消息类型去判断服务器的状态，去做对应的适配操作。</p>
<p>Sentinel主要功能列表：</p>
<ul>
<li>监控（Monitoring）：Sentinel持续检查集群中的master、slave状态，判断是否存活。</li>
<li>通知（Notification）：在发现某个redis实例死的情况下，Sentinel能通过API通知系统管理员或其他程序脚本。</li>
<li>自动故障转移（Automatic failover）：如果一个master挂掉后，sentinel立马启动故障转移，把某个slave提升为master。其他的slave重新配置指向新master，并且应用程序使用Redis服务端通知的新地址。</li>
<li>配置提供者（Configuration provider）：对于客户端来说sentinel通知是有效可信赖的。客户端会连接sentinel去请求当前master的地址，一旦发生故障sentinel会提供新地址给客户端。</li>
</ul>
<p>Redis Sentinel是一个分布式系统：<br>Sentinel（哨兵）自身被设计成和多个哨兵进程一起合作运行。有多个Sentinel（哨兵）进程合作的好处有：<br>1.当多个Sentinel（哨兵）对一个master不再可用达成一致时执行故障检测。这会降低错误判断的概率。<br>2.即使在不是所有的Sentinel（哨兵）都工作时哨兵也会工作，使系统健壮的抵抗故障。毕竟在故障系统里单点故障没有什么意义。<br>Redis的Sentinel（哨兵）、Redis实例(master和slave)、和客户端是一个有特种功能的大型分布式系统。</p>
<h2 id="高可用性解决方案"><a href="#高可用性解决方案" class="headerlink" title="高可用性解决方案"></a>高可用性解决方案</h2><p>由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。<br><img src="/img/redis_HA_1.jpg" alt="示意图"></p>
<p>示例图：<br><img src="/img/redis_HA_2.jpg" alt="示意图"></p>
<h3 id="Sentinel配置"><a href="#Sentinel配置" class="headerlink" title="Sentinel配置"></a>Sentinel配置</h3><p>Sentinel本质上只是一个运行在特殊模式下的redis服务器，通过不同配置来区分提供服务。Redis源码中包含了一个名为sentinel.conf的文件，这个文件是一个带有详细注释的Sentinel 配置。</p>
<p>[监控主服务器名称] [ip] [port] [多少sentinel同意才发生故障转移]</p>
<blockquote>
<p>sentinel monitor mymaster 127.0.0.1 6379 2</p>
</blockquote>
<p>[监控主服务器名称] [master多少毫秒后不回应ping命令，就认为master是主观下线状态]</p>
<blockquote>
<p>sentinel down-after-milliseconds mymaster 6000</p>
</blockquote>
<p>[故障转移超时时间]</p>
<blockquote>
<p>sentinel failover-timeout mymaster 180000</p>
</blockquote>
<p>[在执行故障转移时,最多可以有多少个从服务器同时对新的主服务器进行同步]</p>
<blockquote>
<p>sentinel parallel-syncs mymaster 1</p>
</blockquote>
<ul>
<li><p>down-after-milliseconds解释：</p>
<blockquote>
<p>当实例超过该时间没有返回PING，或者直接返回错误，那么Sentinel将这个实例标记为主观下线（简称SDOWN），只有一个Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移；只有在足够数量的Sentinel 都将一个实例标记为主观下线之后，实例才会被标记为客观下线（简称ODOWN），这时自动故障迁移才会执行。只有一个Sentinel进程将实例标记为主观下线并不一定会引起实例的自动故障迁移，只有在足够数量的Sentinel都将一个实例标记为主观下线之后，实例才会被标记为客观下线，这时自动故障迁移才会执行。</p>
</blockquote>
</li>
<li><p>parallel-syncs解释：</p>
<blockquote>
<p>在发生故障转移主备切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成故障转移所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</p>
</blockquote>
</li>
</ul>
<p>启动后Sentinel会：<br>1.以10秒一次的频率，向被监视的master发送info命令，根据回复获取master当前信息。<br>2.以1秒一次的频率，向所有redis服务器、包含sentinel在内发送PING命令，通过回复判断服务器是否在线。<br>3.以2秒一次的频率，通过向所有被监视的master，slave服务器发送包含当前sentinel，master信息的消息。<br>另外建议sentinel至少起3个实例以上，并配置2个实例同意即可发生转移。 5个实例，配置3个实例同意以此类推。</p>
<h3 id="故障转移消息接收的3种方式"><a href="#故障转移消息接收的3种方式" class="headerlink" title="故障转移消息接收的3种方式"></a>故障转移消息接收的3种方式</h3><p>Redis服务器一旦发送故障后，sentinel通过raft算法投票选举新master。故障转移过程可以通过sentinel的API获取/订阅接收事件消息。</p>
<h4 id="脚本接收"><a href="#脚本接收" class="headerlink" title="脚本接收"></a>脚本接收</h4><p>当故障转移期间，可以指定一个“通知”脚本用来告知系统管理员，当前集群的情况。<br>脚本被允许执行的最大时间为60秒，如果超时，脚本将会被终止(KILL)。</p>
<blockquote>
<p>sentinel notification-script mymaster /var/redis/notify.sh </p>
</blockquote>
<p>故障转移期之后，配置通知客户端的脚本。</p>
<blockquote>
<p>sentinel client-reconfig-script mymaster /var/redis/notifyReconfig.sh </p>
</blockquote>
<h4 id="客户端接收"><a href="#客户端接收" class="headerlink" title="客户端接收"></a>客户端接收</h4><p>Sentinel的故障转移消息通知使用的是redis发布订阅。就是说在故障转移期间所有产生的事件信息，都通过频道(channel)发布出去。比如我们加台slave服务器，sentinel监听到后会发布加slave的消息到”+slave”频道上，客户端只需要订阅”+slave”频道即可接收到对应消息。</p>
<p>其消息格式如下：<br>[实例类型] [事件服务器名称] [服务器ip] [服务器端口] @[master名称] [ip] [端口]</p>
<p><instance-type> <name> <ip> <port> @ <master-name> <master-ip> <master-port></master-port></master-ip></master-name></port></ip></name></instance-type></p>
<p>通知消息格式示例：</p>
<blockquote>
<ul>
<li>//订阅类型， *即订阅所有事件消息。<br>-sdown     //消息类型<br>slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6381</li>
</ul>
</blockquote>
<h4 id="服务间接接收"><a href="#服务间接接收" class="headerlink" title="服务间接接收"></a>服务间接接收</h4><p>这种方式在第二种基础上扩展了一层，即应用端不直接订阅sentinel。 单独做服务去干这件事情，然后应用端提供API供这个服务回调通知。<br>这样做的好处：</p>
<ul>
<li>减少应用端监听失败出错的可能性。</li>
<li>应用端由主动方变成被动方，降低耦合。</li>
<li>性能提高，轮询变回调。</li>
<li>独立成服务可扩展性更高</li>
</ul>
<p>（1）以后换掉sentinel，我们只需要动服务即可，应用端无需更改。<br>（2）可以在服务内多增加一层守护线程去主动拉取redis状态，这样可确保即使sentinel不生效，也能及时察觉redis状态，并通知到应用端。当然这种情况很极端，因为sentinel配的也是多节点，同时挂的几率非常小。</p>
<p>Redis官网sentinel配置介绍：<a href="https://redis.io/topics/sentinel" target="_blank" rel="external">https://redis.io/topics/sentinel</a></p>
]]></content>
    
    <summary type="html">
    
      利用Redis提供的特性，构建低成本高可用的Redis集群。建议使用Redis 3.0及以上稳定版本。
    
    </summary>
    
      <category term="Redis" scheme="https://stefanma.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://stefanma.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看系统资源占用的总结</title>
    <link href="https://stefanma.github.io/2017/05/26/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://stefanma.github.io/2017/05/26/Linux查看系统资源占用的总结/</id>
    <published>2017-05-26T03:40:59.000Z</published>
    <updated>2017-06-26T07:03:51.742Z</updated>
    
    <content type="html"><![CDATA[<p>在系统维护和项目问题分析过程中，随时可能有需要查看 CPU和内存的使用率，并根据相应信息分析系统状况的需求和问题。我们需要知道和用到Linux系统资源查看命令。</p>
<h2 id="命令：top"><a href="#命令：top" class="headerlink" title="命令：top"></a>命令：top</h2><p>top命令用来显示执行中的程序进程，使用权限是所有用户。<br><img src="/img/linux_cmd_1.png" alt="示意图"><br>第一行表示的项目依次为当前时间、系统启动时间、当前系统登录用户数目、平均负载。第二行显示的是所有启动的进程、目前运行的、挂起(Sleeping)的和无用(Zombie)的进程。第三行显示的是目前CPU的使用情况，包括系统占用的比例、用户使用比例、闲置(Idle)比例。第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。第五行显示交换分区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。<br>第六行显示的项目：<br>PID（Process ID）：进程标示号。<br>USER：进程所有者的用户名。<br>PR：进程的优先级别。<br>NI：进程的优先级别数值。<br>VIRT：进程占用的虚拟内存值。<br>RES：进程占用的物理内存值。<br>SHR：进程使用的共享内存值。<br>S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。<br>%CPU：该进程占用的CPU使用率。<br>%MEM：该进程占用的物理内存和总内存的百分比。<br>TIME＋：该进程启动后占用的总的CPU时间。<br>Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。</p>
<h2 id="命令：free"><a href="#命令：free" class="headerlink" title="命令：free"></a>命令：free</h2><p>free命令用来显示内存的使用情况，使用权限是所有用户。<br>格式：free [－b－k－m] [－o] [－s delay] [－t] [－V]</p>
<p>free -m -s5（终端会连续不断地报告内存使用情况（以MB为单位），每5秒更新一次。）<br><img src="/img/linux_cmd_2.png" alt="示意图"></p>
<p>Mem行：total = used  + free    其中buffers和cached虽然计算在used内， 但其实为可用内存。<br>Mem下一行：used为真实已占内存，free为真实可用内存。<br>Swap：内存交换区的使用情况。</p>
<h2 id="命令：ps-auxw-head-1-ps-auxw-sort-rn-k4-head-5"><a href="#命令：ps-auxw-head-1-ps-auxw-sort-rn-k4-head-5" class="headerlink" title="命令：ps auxw | head -1;ps auxw|sort -rn -k4|head -5"></a>命令：ps auxw | head -1;ps auxw|sort -rn -k4|head -5</h2><p>查看内存占用前五的进程<br><img src="/img/linux_cmd_3.png" alt="示意图"></p>
<p>内存的单位是KB，VSZ是虚拟内存的占用，RSS是真实的内存的占用。<br>ps auxw：显示系统资源占用情况。<br>head -1：表示显示第一列，即标题列。<br>sort -r：表示反向排序，-n表示按数字排序，-k4表示列的第4个字符。</p>
<h2 id="命令：pstree-pstree-p"><a href="#命令：pstree-pstree-p" class="headerlink" title="命令：pstree/pstree -p"></a>命令：pstree/pstree -p</h2><p>查看进程树，ps aux查看进程，如果进程太多看起来很不方便，可以使用pstree以树形方式显示正在运行的所有进程。<br><img src="/img/linux_cmd_4.png" alt="示意图"></p>
]]></content>
    
    <summary type="html">
    
      在项目中用到的查看Linux的系统资源占用
    
    </summary>
    
      <category term="Linux" scheme="https://stefanma.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://stefanma.github.io/tags/Linux/"/>
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统数据一致性的思考（一）</title>
    <link href="https://stefanma.github.io/2017/04/12/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://stefanma.github.io/2017/04/12/分布式系统数据一致性的思考/</id>
    <published>2017-04-12T06:54:26.000Z</published>
    <updated>2017-05-22T11:34:31.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>说到分布式系统的设计，我们都或多或少的接触过CAP；CAP代表的是什么呢？</p>
<blockquote>
<p><strong>Consistency(一致性)，数据一致更新，所有数据变动都是同步的；所有的节点上的数据时刻保持同步；</strong><br>  <strong>Availability(可用性)，好的响应性能；每个请求都能接受到一个响应，无论响应成功或失败；</strong><br>  <strong>Partition tolerance(分区容错) ，可靠性；系统应该能持续提供服务，即使系统内部有消息丢失（分区）；</strong></p>
</blockquote>
<p>CAP理论在互联网界有着广泛的知名度，知识宽泛一点的工程师都会把其作为衡量系统设计的准则。我们非常清楚地理解了CAP：任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能得其二，因此，任何分布式系统的设计只是在三者中的不同取舍而已。（CAP在国内比价响，在国外的响力完全不如所想，相反还伴随着诸多的争论。）可以肯定的是，CAP并不适合再作为一个适应任何场景的定理，它的正确性更加适合基于原子读写的NoSQL场景。</p>
<h2 id="高可用框架中数据一致性"><a href="#高可用框架中数据一致性" class="headerlink" title="高可用框架中数据一致性"></a>高可用框架中数据一致性</h2><p>在某些电商的业务场景下，系统一般会有多个独立的服务组成的，比如在一个业务场景下，一个业务操作同时调用了A，B，C服务，需要满足要么同时成功，要么同时失败。A，B，C可能是不同的部门开发的，部署在不同机器上的远程服务。</p>
<p>对于分布式系统来说，如果不想牺牲一致性，CAP的理论告诉我们要弃用可用性，对于有些场景下是不能接受的。<br>说到数据一致性，先介绍一下数据一致性的理论基础：</p>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。当然这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。强一致性可以理解为在任意时刻，所有节点中的数据是一样的。</p>
<h3 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h3><p>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。</p>
<blockquote>
<p>在系统的实践中，为了保证系统的高可用性，互联网系统大多将强一致性需求转换成最终一致性的需求并通过系统执行幂等性的保证，保证数据的最终一致性。</p>
</blockquote>
<h2 id="BASE和方案"><a href="#BASE和方案" class="headerlink" title="BASE和方案"></a>BASE和方案</h2><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE是指基本可用（Basically Available）、软状态（Soft State）、最终一致性（Eventual Consistency）。BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。ACID和BASE代表了两种截然相反的设计哲学；在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>
<h3 id="方案一【消息日志-本地事务】"><a href="#方案一【消息日志-本地事务】" class="headerlink" title="方案一【消息日志+本地事务】"></a>方案一【消息日志+本地事务】</h3><p>为了保证系统数据的最终一致性，可以使用本地事务来操作。<br>首先需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。<br>消息日志的方案核心是保证服务接口的幂等性。考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。<br>其中一个经典的解决方法，来达到多次重试的幂等性。最常见的场景，如果产生一笔交易，需要在交易表中增加记录，同时还要修改用户表的金额，将主要的修改操作和更新用户表的消息放在一个本地事务来完成；为了避免重复消费用户表的消息带来的问题，达到多次重试的幂等性，增加一个更新记录表来记录已经处理过的消息。<br>基于以上的方法，在第一阶段，通过本地的数据库的事务保障，增加事务表以及消息队列。<br>在第二阶段，分别读出消息队列，通过判断更新记录表来检测相关的记录是否被执行，未被执行的记录会修改用户表然后增加一条操作记录到更新记录表，事务执行成功之后再删除队列。</p>
<h3 id="方案二【分布式事务】"><a href="#方案二【分布式事务】" class="headerlink" title="方案二【分布式事务】"></a>方案二【分布式事务】</h3><p>目前很多的电商系统随着业务规模的扩大，将原来的一个单体应用拆分成多个不同职责的子系统。最开始的单体应用所有的功能都在一起，存储也在一起，可以在一个事务中，有关系数据库来保证一致性。<br>但是拆分之后就不同了，不同的子系统都有自己的存储，通过接口、RPC等方式来调用不同的子系统的服务，而不是直接操作数据库。这就涉及到一个[分布式事务]的问题。<br>对于分布式事务的解决方案，一般有2种。<br>(1)优先使用异步消息<br>在使用异步消息的时候消费者端要实现幂等。<br>实现幂等的方式有2种，一种是业务逻辑保证幂等。比如接到支付成功的消息订单状态要变成支付完成，如果当前状态是支付完成，则再收到一个支付成功的消息说明消息重复了，直接作为消息成功处理。另一种方式是如果业务逻辑无法保证幂等，则要增加一个去重表或是类似的实现。对于消息生产者端在业务数据库的同实例中放一个消息库，发消息和业务操作在同一个本地事务中。发消息的时候并不立即发出，而是向消息库中插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送成功则将消息库中消息删除，如果遇到消息队列服务异常或者网络异常，消息没有成功发出消息还留在库里，会有另一个服务不断的将这些消息扫出重新发送。</p>
<p>(2)每个业务库使用一个事务记录库<br>有的业务不适合使用异步消息的方式，事务的各个参与方都需要同步的得到结果。采取在每个参与方的本地业务库中的同实例中放一个事务记录库。<br>比如A同步调用B，C。A本地事务成功的时候更新本地事务记录状态，B和C同样。如果有一次A调用B失败了，有可能是B真的失败了，也有可能是调用超时，实际上B成功了。则由一个中心服务对比三方的事务记录表，做一个最终的决定。假设在三方的事务表中，有的成功，有的失败。</p>
<p><1>重试B，只到B成功，事务表里记录了各项调用参数等信息；</1></p>
<p><2>执行A和B的补偿操作（一种可行补偿方式就是回滚）<br>那么会有人觉得在业务库中的同实例中存放消息库或是事务记录库，会对业务侵入，业务还需要关心这个，是否是一个合理的设计？<br>实际上可以依靠运维手段来简化开发的侵入，可以采用的方法是通过DBA在MySQL实例上预初始化这个库，通过框架层（消息的客户端或事务RPC框架）透明的在背后操作这个库，业务开发人员只需要关心自己的业务逻辑，不需要访问这个库。<br>总结起来，两种方式的原理是类似的，也就是将分布式事务转换成多个本地事务，然后依靠重试等方式达到最终一致性。</2></p>
]]></content>
    
    <summary type="html">
    
      有关分布式系统数据一致性的思考以及方案
    
    </summary>
    
      <category term="分布式" scheme="https://stefanma.github.io/categories/distributed/"/>
    
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper系列学习：解决分布式系统中的单点故障</title>
    <link href="https://stefanma.github.io/2017/04/02/Zookeeper%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C/"/>
    <id>https://stefanma.github.io/2017/04/02/Zookeeper系列学习：解决分布式系统中的单点故障/</id>
    <published>2017-04-02T07:54:09.000Z</published>
    <updated>2017-06-28T10:43:37.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>现在很多时候我们的服务需要7*24小时工作，假如一台机器挂了，我们希望能有其它机器顶替它继续工作。此类问题现在多采用master-salve模式，也就是常说的主从模式，正常情况下主机提供服务，备机负责监听主机状态，当主机异常时，可以自动切换到备机继续提供服务，这个切换过程中选出下一个主机的过程就是master选举。</p>
<p>传统的解决方式是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包后会向备用节点发送应答ack，当备用节点收到应答，就认为主节点还活着，让它继续提供服务，否则就认为主节点挂掉了，自己将开始行使主节点职责。<br><img src="/img/zookeeper_apl_1.png" alt="示意图"></p>
<p>当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点。<br><img src="/img/zookeeper_apl_2.png" alt="示意图"></p>
<p>但是这种方式就是有一个隐患，就是网络问题。主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是—双Master，出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了。<br><img src="/img/zookeeper_apl_3.png" alt="示意图"></p>
<h2 id="使用ZooKeeper"><a href="#使用ZooKeeper" class="headerlink" title="使用ZooKeeper"></a>使用ZooKeeper</h2><p>ZooKeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。Zookeeper不仅能够维护当前的集群中机器的服务状态，而且能够选出一个“总管”，让这个总管来管理集群。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>实现方式都是在ZooKeeper上创建一个 EPHEMERAL 类型的目录节点，然后每个Server在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch为true，由于是 EPHEMERAL 目录节点，当创建它的Server死去，这个目录节点也随之被删除，所以Children将会变化，这时 getChildren上的Watch将会被调用，所以其它 Server就知道已经有某台Server死去了。新增 Server 也是同样的原理。<br>和前面的一样每台Server创建一个EPHEMERAL目录节点，不同的是它还是一个SEQUENTIAL目录节点，所以它是个EPHEMERAL_SEQUENTIAL目录节点。之所以它是EPHEMERAL_SEQUENTIAL目录节点，是因为我们可以给每台Server编号，我们可以选择当前是最小编号的Server为Master，假如这个最小编号的Server死去，由于是EPHEMERAL节点，死去的Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前Master。这样就实现了动态选择Master，避免了传统意义上单Master 容易出现单点故障的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>1.启动<br>引入了Zookeeper以后我们启动了两个主节点，”主节点-A”和”主节点-B”他们启动以后，都向ZooKeeper去注册一个节点。假设”主节点-A”锁注册地节点是”master-00001”，”主节点-B”注册的节点是”master-00002”，注册完以后进行选举，编号最小的节点将在选举中获胜获得锁成为主节点，也就是我们的”主节点-A”将会获得锁成为主节点，然后”主节点-B”将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个Master进程的调度。<br><img src="/img/zookeeper_apl_4.png" alt="示意图"></p>
<p>2.故障处理<br>如果”主节点-A”挂了，这时候他所注册的节点将被自动删除，ZooKeeper会自动感知节点的变化，然后再次发出选举，这时候”主节点-B”将在选举中获胜，替代”主节点-A”成为主节点。<br><img src="/img/zookeeper_apl_5.png" alt="示意图"></p>
<p>3.恢复<br>如果主节点恢复了，他会再次向ZooKeeper注册一个节点，这时候他注册的节点将会是”master-00003”，ZooKeeper会感知节点的变化再次发动选举，这时候”主节点-B”在选举中会再次获胜继续担任”主节点”，”主节点-A”会担任备用节点。<br><img src="/img/zookeeper_apl_6.png" alt="示意图"></p>
]]></content>
    
    <summary type="html">
    
      利用ZooKeeper的特性，在分布式锁服务中，解决分布式系统中的单点故障
    
    </summary>
    
      <category term="分布式" scheme="https://stefanma.github.io/categories/distributed/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ZooKeeper" scheme="https://stefanma.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper系列学习：数据模型和特点</title>
    <link href="https://stefanma.github.io/2017/03/06/Zookeeper%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%89%B9%E7%82%B9/"/>
    <id>https://stefanma.github.io/2017/03/06/Zookeeper系列学习：数据模型和特点/</id>
    <published>2017-03-06T11:51:17.000Z</published>
    <updated>2017-06-28T07:41:14.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ZooKeeper数据模型"><a href="#ZooKeeper数据模型" class="headerlink" title="ZooKeeper数据模型"></a>ZooKeeper数据模型</h2><p>紧接着上一篇的概述中所写的数据模型的概述，接下来对数据模型比较详细的阐述。</p>
<p>ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，都是采用树形层次结构，ZooKeeper树中的每个节点被称为—Znode。和文件系统的目录树一样，ZooKeeper目录树中每一个节点对应一个Znode，ZooKeeper树中的每个节点可以拥有子节点。每个Znode上可存储少量数据。用户对Znode具有增、删、改、查等操作（权限允许的情况下）。<br>Znode具有原子性操作，每个Znode的数据将被原子性地读写，读操作会读取与Znode相关的所有数据，写操作会一次性替换所有数据。<br>每个Znode维护着一个属性结构，它包含着版本号(dataVersion)，时间戳(ctime,mtime)等状态信息。ZooKeeper正是使用节点的这些特性来实现它的某些特定功能。每当Znode的数据改变时，他相应的版本号将会增加。每当客户端检索数据时，它将同时检索数据的版本号。并且如果一个客户端执行了某个节点的更新或删除操作，他也必须提供要被操作的数据版本号。如果所提供的数据版本号与实际不匹配，那么这个操作将会失败。</p>
<p>Znode是客户端访问ZooKeeper的主要实体，它包含以下几个特征：<br>（1）Watches<br>客户端可以在节点上设置watch(我们称之为监视器)。当节点状态发生改变时(数据的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。<br>（2）数据访问<br>ZooKeeper中的每个节点存储的数据要被原子性的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。<br>（3）Znode节点类型<br>ZooKeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即被确定，并且不能改变。<br>①临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节点不允许拥有子节点。<br>②永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。<br>ZooKeeper的永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。<br>（4）顺序节点（唯一性的保证）<br>当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个递增的计数。这个计数对于此节点的父节点来说是唯一的，它的格式为”%10d”(10位数字，没有数值的数位用0补充，例如”0000000001”)。当计数值大于2^32-1时，计数器将溢出。<br>org.apache.zookeeper.CreateMode中定义了四种节点类型，分别对应：<br>PERSISTENT：永久节点<br>EPHEMERAL：临时节点<br>PERSISTENT_SEQUENTIAL：永久节点、序列化<br>EPHEMERAL_SEQUENTIAL：临时节点、序列化<br><img src="/img/zookeeper_1.png" alt="示意图"></p>
<h2 id="ZooKeeper服务中的操作"><a href="#ZooKeeper服务中的操作" class="headerlink" title="ZooKeeper服务中的操作"></a>ZooKeeper服务中的操作</h2><p>在ZooKeeper中有9个基本操作:<br><img src="/img/zookeeper_2.png" alt="示意图"><br>更新ZooKeeper操作是有限制的。delete或setData必须明确要更新的Znode的版本号，我们可以调用exists找到。如果版本号不匹配，更新将会失败。<br>更新ZooKeeper操作是非阻塞式的。因此客户端如果失去了一个更新（由于另一个进程在同时更新这个Znode），他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。<br>尽管ZooKeeper可以被看做是一个文件系统，但是处于便利，摒弃了一些文件系统地操作原语。因为文件非常的小并且使整体读写的，所以不需要打开、关闭或是寻地的操作。</p>
<p>每个Znode由3部分组成:<br>1.stat：此为状态信息, 描述该Znode的版本, 权限等信息。<br>2.data：与该Znode关联的数据。<br>3.children：该Znode下的子节点。</p>
<p>Zonde总结<br>（1）Znode中的数据可以有多个版本，在查询该Znode数据时就需要带上版本信息。如：set path version / delete path version<br>（2）Znode可以是临时Znode，由create -e 生成的节点，一旦创建这个Znode的client与server断开连接，该Znode将被自动删除。<br>client和server之间通过heartbeat来确认连接正常，这种状态称之为session，断开连接后session失效。<br>（3）临时Znode不能有子Znode。<br>（4）Znode可以自动编号，由create -s 生成的节点，例如在 create -s /app/node 已存在时，将会生成 /app/node00<em>*</em>001节点。<br>（5）Znode可以被监控，该目录下某些信息的修改，例如节点数据、子节点变化等，可以主动通知监控注册的client。事实上，通过这个特性，可以完成许多重要应用，例如配置管理、信息同步、分布式锁等等。</p>
<h2 id="ACL对Znode进行访问控制"><a href="#ACL对Znode进行访问控制" class="headerlink" title="ACL对Znode进行访问控制"></a>ACL对Znode进行访问控制</h2><p>ZooKeeper使用ACL来对Znode进行访问控制。ACL的实现和Unix文件访问许可非常相似：它使用许可位来对一个节点的不同操作进行允许或禁止的权限控制。但是，和标准的Unix许可不同的是，Zookeeper对于用户类别的区分，不止局限于所有者(owner)、组 (group)、所有人(world)三个级别。Zookeeper中，数据节点没有“所有者”的概念。访问者利用id标识自己的身份，并获得与之相应的不同的访问权限。</p>
<p>ZooKeeper的节点有5种操作权限：<br>CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)。<br><img src="/img/zookeeper_2.png" alt="示意图"></p>
<p>ACL可以控制访问ZooKeeper的节点，只能应用于特定的Znode上，而不能应用于该Znode的所有孩子节点上。它主要有如下五种权限：<br>CREATE 允许创建Child Nodes<br>READ 允许获取Znode的数据，以及该节点的孩子列表<br>WRITE 可以修改Znode的数据<br>DELETE 可以删除一个孩子节点<br>ADMIN 可以设置权限</p>
<blockquote>
<p>注：这5种权限中，delete是指对子节点的删除权限，其它4种权限指对自身节点的操作权限。</p>
</blockquote>
<p>更新ZooKeeper操作是有限制的。delete或setData必须明确要更新的Znode的版本号，我们可以调用exists找到。如果版本号不匹配，更新将会失败。<br>更新ZooKeeper操作是非阻塞式的。因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode)，他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。<br>尽管ZooKeeper可以被看做是一个文件系统，但是处于便利，摒弃了一些文件系统地操作原语。因为文件非常的小并且使整体读写的，所以不需要打开、关闭或是寻地的操作。</p>
<h2 id="Watches（监视）"><a href="#Watches（监视）" class="headerlink" title="Watches（监视）"></a>Watches（监视）</h2><p>Znode发生变化（Znode本身的增加，删除，修改，以及子Znode的变化）可以通过Watch机制通知到客户端。<br>1.一次性的触发器（one-time trigger）<br>ZooKeeper中的Watch是只能触发一次。也就是说，如果客户端在指定的Znode设置了Watch，如果该Znode数据发生变更，ZooKeeper会发送一个变更通知给客户端，同时触发设置的Watch事件。如果Znode数据又发生了变更，客户端在收到第一次通知后没有重新设置该Znode的Watch，则ZooKeeper就不会发送一个变更通知给客户端。Watch机制规定了它是一个一次性的触发器。<br>当设置监视的数据发生改变时，该监视事件会被发送到客户端，例如，如果客户端调用了 getData(“/znode1”, true) 并且稍后 /znode1 节点上的数据发生了改变或者被删除了，客户端将会获取到 /znode1 发生变化的监视事件，而如果 /znode1 再一次发生了变化，除非客户端再次对 /znode1 设置监视，否则客户端不会收到事件通知。</p>
<p>2.发送给客户端（Sent to the client）<br>ZooKeeper异步通知设置Watch的客户端。但是ZooKeeper能够保证在Znode的变更生效之后才会异步地通知客户端，然后客户端才能够看到Znode的数据变更。由于网络延迟，多个客户端可能会在不同的时间看到Znode数据的变更，但是看到变更的顺序是能够保证有序一致的。这就表明不同的客户端收到的Watch的时间可能不同，但是ZooKeeper有保证：当一个客户端在看到Watch事件之前是不会看到结点数据的变化的。</p>
<p>Zookeeper 客户端和服务端是通过Socket进行通信的，由于网络存在故障，所以监视事件很有可能不会成功地到达客户端，监视事件是异步发送至监视者的，Zookeeper 本身提供了保序性(ordering guarantee)：即客户端只有首先看到了监视事件后，才会感知到它所设置监视的Znode发生了变化网络延迟或者其他因素可能导致不同的客户端在不同的时刻感知某一监视事件，但是不同的客户端所看到的一切具有一致的顺序。</p>
<p>3.被设置Watch的数据（The data for which the watch was set）<br>Zookeeper 维护了两条监视链表：数据监视和子节点监视(data watches and child watches)，getData()和exists()设置数据监视，getChildren()设置子节点监视。<br>Znode可以设置两类Watch，一个是Data Watches（该Znode的数据变更导致触发Watch事件），另一个是Child Watches（该Znode的孩子节点发生变更导致触发Watch事件）。调用getData()和exists() 方法可以设置Data Watches，调用getChildren()方法可以设置Child Watches。调用setData()方法触发在该Znode的注册的Data Watches。调用create()方法创建一个Znode，将触发该Znode的Data Watches；调用create()方法创建Znode的孩子节点，则触发Znode的Child Watches。调用delete()方法删除Znode，则同时触发Data Watches和Child Watches，如果该被删除的Znode还有父节点，则父节点触发一个Child Watches。</p>
<h3 id="Watch注册与处触发"><a href="#Watch注册与处触发" class="headerlink" title="Watch注册与处触发"></a>Watch注册与处触发</h3><p><img src="/img/zookeeper_3.png" alt="示意图"><br>1.exists操作上的Watch，在被监视的Znode创建、删除或数据更新时被触发。<br>2.getData操作上的Watch，在被监视的Znode删除或数据更新时被触发。在被创建时不能被触发，因为只有Znode一定存在，getData操作才会成功。<br>3.getChildren操作上的Watch，在被监视的Znode的子节点创建或删除，或是这个Znode自身被删除时被触发。可以通过查看Watch事件类型来区分是Znode，还是他的子节点被删除：NodeDelete表示Znode被删除，NodeDeletedChanged表示子节点被删除。</p>
<p>Watch由客户端所连接的ZooKeeper服务器在本地维护，因此watch可以非常容易地设置、管理和分派。当客户端连接到一个新的服务器时，任何的会话事件都将可能触发Watch。另外，当从服务器断开连接的时候，Watch将不会被接收。但是，当一个客户端重新建立连接的时候，任何先前 注册过的watch都会被重新注册。</p>
]]></content>
    
    <summary type="html">
    
      ZooKeeper的数据模型和特性
    
    </summary>
    
      <category term="分布式" scheme="https://stefanma.github.io/categories/distributed/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ZooKeeper" scheme="https://stefanma.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper系列学习：概述</title>
    <link href="https://stefanma.github.io/2017/03/05/Zookeeper%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%A6%82%E8%BF%B0/"/>
    <id>https://stefanma.github.io/2017/03/05/Zookeeper系列学习：概述/</id>
    <published>2017-03-05T11:52:55.000Z</published>
    <updated>2017-07-07T07:39:30.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ZooKeeper是什么，可以用作什么"><a href="#ZooKeeper是什么，可以用作什么" class="headerlink" title="ZooKeeper是什么，可以用作什么"></a>ZooKeeper是什么，可以用作什么</h2><p>官方一句话描述”ZooKeeper: A Distributed Coordination Service for Distributed Applications”。</p>
<p>ZooKeeper作为Hadoop项目中的一个子项目,是Hadoop集群管理的一个必不可少的模块,它主要用来解决分布式应用中经常遇到的数据管理问题，如集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等，是分布式中一致性处理的框架的重要组件。</p>
<p>所谓的一致性，实际上就是围绕着“看见”来的。谁能看见？能否看见？什么时候看见？举个例子：淘宝后台卖家，在后台上架一件大促的商品，通过服务器A提交到主数据库，假设刚提交后立马就有用户去通过应用服务器B去从数据库查询该商品，就会出现一个现象，卖家已经更新成功了，然而买家却看不到；而经过一段时间后，主数据库的数据同步到了从数据库，买家就能查到了。<br>假设卖家更新成功之后买家立马就能看到卖家的更新，则称为<code>强一致性</code>；<br>如果卖家更新成功后买家不能看到卖家更新的内容，则称为<code>弱一致性</code>；<br>而卖家更新成功后，买家经过一段时间最终能看到卖家的更新，则称为<code>最终一致性</code>。</p>
<h2 id="解决一致性问题的方式"><a href="#解决一致性问题的方式" class="headerlink" title="解决一致性问题的方式"></a>解决一致性问题的方式</h2><h3 id="常见解决问题的方式"><a href="#常见解决问题的方式" class="headerlink" title="常见解决问题的方式"></a>常见解决问题的方式</h3><p>如何保证在分布式环境下数据的最终一致，这个就是ZooKeeper需要解决的问题。<br>一些常见的解决一致性问题的方式：<br>（1）查询重试补偿<br>对于分布式应用中不确定的情况，先使用查询接口查询到当前状态，如果当前状态不一致则采用补偿接口对状态进行重试推进，或者回滚接口对业务做回滚。典型的场景如银行跟支付宝之间的交互。支付宝发送一个转账请求到银行，如一直未收到响应，则可以通过银行的查询接口查询该笔交易的状态，如该笔交易对方未收到，则采取补偿的模式进行推送。<br>（2）定时任务推送<br>有可能一次推送搞不定，于是需要2次，3次推送。当初支付宝内最初掉单率很高，全靠后续不断的定时任务推送增加成功率。<br>（3）TCC<br>try-confirm-cancel。实际上是两阶段协议，第二阶段的可以实现提交操作或是逆操作。</p>
<h3 id="ZooKeeper能做什么"><a href="#ZooKeeper能做什么" class="headerlink" title="ZooKeeper能做什么"></a>ZooKeeper能做什么</h3><p>Dubbo作为业界知名的分布式SOA框架，Dubbo的主要的服务注册发现功能便是由ZooKeeper来提供的。<br>对于一个服务框架，注册中心是其核心中的核心，虽然暂时挂掉并不会导致整个服务出问题，但是一旦挂掉，整体风险就很高。考虑一般情况，注册中心就是单台机器的时候，其实现很容易，所有机器起来都去注册服务给它，并且所有调用方都跟它保持长连接，一旦服务有变，即通过长连接来通知到调用方。但是当服务集群规模扩大时，这事情就不简单了，单机保持连接数有限，而且容易故障。<br>作为一个稳定的服务化框架，dubbo可以选择并推荐ZooKeeper作为注册中心。其底层将ZooKeeper常用的客户端zkclient和curator封装成为ZooKeeperClient。<br>（1）当服务提供者服务启动时，向ZooKeeper注册一个节点；<br>（2）服务消费者则订阅其父节点的变化，诸如启动停止都能够通过节点创建删除得知，异常情况比如被调用方掉线也可以通过临时节点session 断开自动删除得知；<br>（3）服务消费方同时也会将自己订阅的服务以节点创建的方式放到ZooKeeper；<br>（4）于是可以得到映射关系，诸如谁提供了服务，谁订阅了谁提供的服务，基于这层关系再做监控，就能轻易得知整个系统情况。</p>
<h2 id="ZooKeeper的数据模型"><a href="#ZooKeeper的数据模型" class="headerlink" title="ZooKeeper的数据模型"></a>ZooKeeper的数据模型</h2><p>ZooKeeper数据模型类似Linux操作系统的文件系统，也是以树的形式来存储。严格来说是一颗多叉树，每个节点上都可以存储数据，每个节点还可以拥有N个子结点，最上层是根节点以“/”来代表。<br><img src="/img/zookeeper_0.jpg" alt="示意图"><br>在每个结点上都存储了相应的数据，数据可以是字符串、二进制数。但是默认情况下每个结点的数据大小的上限是1M，这是因为ZooKeeper主要是用来协调服务的，而不是存储数据，管理一些配置文件和应用列表之类的数据。虽然可以修改配置文件来改变数据大小的上限，但是为了服务的高效和稳定，建议结点数据不要超过默认值。<br>在ZooKeeper中存储的创建的结点和存储的数据包含结点的创建时间、修改时间、结点id、结点中存储数据的版本、权限版本、孩子结点的个数、数据的长度等信息。<br>每个节点的Stat结构由下列字段组成：</p>
<ul>
<li>czxid：该数据节点被创建时的事务id。</li>
<li>mzxid：该节点最后一次被更新时的事务id。</li>
<li>ctime：节点被创建时的时间。</li>
<li>mtime：节点最后一次被更新时的时间。</li>
<li>version：这个节点的数据变化的次数。</li>
<li>cversion：这个节点的子节点 变化次数。</li>
<li>aversion：这个节点的ACL变化次数。</li>
<li>ephemeralOwner：如果这个节点是临时节点，表示创建者的会话id。如果不是临时节点，这个值是0。</li>
<li>dataLength：这个节点的数据长度。</li>
<li>numChildren：这个节点的子节点个数。</li>
</ul>
<p>其节点有如下有趣而又重要的特性：<br>（1）同一时刻多台机器创建同一个节点，只有一个会争抢成功。利用这个特性可以做分布式锁。<br>（2）临时节点的生命周期与会话一致，会话关闭则临时节点删除。这个特性经常用来做心跳，动态监控，负载等动作。<br>（3）顺序节点保证节点名全局唯一。这个特性可以用来生成分布式环境下的全局自增长ID。</p>
]]></content>
    
    <summary type="html">
    
      ZooKeeper的概述
    
    </summary>
    
      <category term="分布式" scheme="https://stefanma.github.io/categories/distributed/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ZooKeeper" scheme="https://stefanma.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL的简介</title>
    <link href="https://stefanma.github.io/2017/03/04/PostgreSQL%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
    <id>https://stefanma.github.io/2017/03/04/PostgreSQL的简介/</id>
    <published>2017-03-04T07:53:41.000Z</published>
    <updated>2017-05-04T08:05:03.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES，现在已经更名为PostgreSQL，版本4.2为基础的对象关系型数据库管理系统（ORDBMS）。POSTGRES开创的许多概念在很久以后才出现在商业数据库中。<br>PostgreSQL支持大部分SQL标准并且提供了许多其它现代特性：</p>
<ul>
<li>复杂查询</li>
<li>外键</li>
<li>触发器</li>
<li>可更新的视图</li>
<li>事务完整性</li>
<li>多版本并发控制<br>另外，PostgreSQL可以用许多方法进行扩展，比如通过增加新的：</li>
<li>数据类型</li>
<li>函数</li>
<li>操作符</li>
<li>聚合函数</li>
<li>索引方法</li>
<li>过程语言</li>
</ul>
<p>PostgreSQL的特点如下：</p>
<ul>
<li>PostgreSQL可在所有主要操作系统(即Linux，UNIX(AIX，BSD，HP-UX，SGI IRIX，Mac OS X，Solaris，Tru64)和Windows等)上运行。</li>
<li>PostgreSQL支持文本，图像，声音和视频，并包括用于C/C++，Java，Perl，Python，Ruby，Tcl和开放数据库连接(ODBC)的编程接口。</li>
<li>PostgreSQL支持SQL的许多功能，例如复杂SQL查询，SQL子选择，外键，触发器，视图，事务，多进程并发控制(MVCC)，流式复制(9.0)，热备(9.0))。</li>
<li>在PostgreSQL中，表可以设置为从“父”表继承其特征。</li>
<li>可以安装多个扩展以向PostgreSQL添加附加功能</li>
</ul>
<p>PostgreSQL官方宣称的是：“The world’s most advanced open source database”。PosgreSQL还是传统B+树索引的数据库，在一些场景下，比如全插入场景，其还是会比其他一些数据库要来得差很多，比如TokuDB，MongoDB。PostgreSQL另一个痛点，我想很多人没有会意识到的，就是在在线事务（OLTP）方面的性能问题。PostgreSQL在功能方面或许是比较完整的，但是真的要进入到生产环节，看的不再是简单的功能，因为大部分用户都明白日常所使用的仅是数据库提供的20%功能。MySQL 5.7现在已经可以轻松达到50W QPS的性能，并支持通过NoSQL接口可以达到100W QPS，这是PostgreSQL为什么没有能在互联网时代站住脚跟的一个重要原因之一。在线事务对性能的要求之苛刻，是普通用户所无法感知的。</p>
<p>PostgreSQL最大的优势是在线分析的场景，因为其优化器对于Join的支持堪称全面，对于复杂查询有着良好的支持，从Oracle迁移到PostgreSQL的成本会比较低。基于PostgreSQL的GreenPlum也已经开源，因此PostgreSQL目前在这方便是较为领先的。</p>
<p>官方地址：<a href="https://www.postgresql.org/" target="_blank" rel="external">https://www.postgresql.org/</a></p>
]]></content>
    
    <summary type="html">
    
      PostgreSQL的简介
    
    </summary>
    
      <category term="PostgreSQL" scheme="https://stefanma.github.io/categories/PostgreSQL/"/>
    
    
      <category term="Linux" scheme="https://stefanma.github.io/tags/Linux/"/>
    
      <category term="PostgreSQL" scheme="https://stefanma.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>对于热点缓存的思考</title>
    <link href="https://stefanma.github.io/2017/02/04/%E5%AF%B9%E4%BA%8E%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://stefanma.github.io/2017/02/04/对于热点缓存的思考/</id>
    <published>2017-02-04T12:09:02.000Z</published>
    <updated>2017-06-02T06:49:39.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="热点key问题"><a href="#热点key问题" class="headerlink" title="热点key问题"></a>热点key问题</h2><p>项目中通常使用 缓存+过期时间 的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新，一般情况下这种模式已经基本满足要求了。<br>但是有两个问题如果同时出现，可能就会对系统造成致命的危害：<br>1.这个key是一个热点key（例如一个重要的新闻，一个热门的八卦新闻等等），所以这种key访问量可能非常大。<br>2.缓存的构建是需要一定时间的。（可能是一个复杂计算，例如复杂的sql、多次IO、多个依赖(各种接口)等等）。</p>
<p>于是就会出现一个致命问题：在缓存失效的瞬间，有大量线程来构建缓存，造成后端负载加大，甚至可能会让系统崩溃。<br><img src="/img/mutex_key_0.jpg" alt="示意图"></p>
<h2 id="四种解决方案"><a href="#四种解决方案" class="headerlink" title="四种解决方案"></a>四种解决方案</h2><p><strong>我们的目标是：尽量少的线程构建缓存(甚至是一个) &amp;&amp; 数据一致性 &amp;&amp; 较少的潜在危险。</strong></p>
<h3 id="使用互斥锁的方案"><a href="#使用互斥锁的方案" class="headerlink" title="使用互斥锁的方案"></a>使用互斥锁的方案</h3><p><strong>这种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以。</strong><br><img src="/img/mutex_key_1.jpg" alt="示意图"><br>如果是单机，可以用synchronized或者lock来处理；<br>如果是分布式环境可以用分布式锁就可以；分布式锁，可以用memcache的add，或者redis的setnx[SET if Not eXists], zookeeper的添加节点操作。</p>
<p>redis代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;  </div><div class="line">   String value = redis.get(key);  </div><div class="line">   <span class="keyword">if</span> (value  == <span class="keyword">null</span>) &#123;  </div><div class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">"1"</span>)) &#123;  </div><div class="line">        <span class="comment">// 3 min timeout to avoid mutex holder crash  </span></div><div class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)  </div><div class="line">        value = db.get(key);  </div><div class="line">        redis.set(key, value);  </div><div class="line">        redis.delete(key_mutex);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        <span class="comment">//其他线程休息50毫秒后重试  </span></div><div class="line">        Thread.sleep(<span class="number">50</span>);  </div><div class="line">        get(key);  </div><div class="line">    &#125;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“提前”使用互斥锁"><a href="#“提前”使用互斥锁" class="headerlink" title="“提前”使用互斥锁"></a>“提前”使用互斥锁</h3><p>在value内部设置1个超时值(timeout1)，timeout1比实际的timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。</p>
<p>memcache的代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">v = memcache.get(key);  </div><div class="line"><span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;  </div><div class="line">    <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </div><div class="line">        value = db.get(key);  </div><div class="line">        memcache.set(key, value);  </div><div class="line">        memcache.delete(key_mutex);  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        sleep(<span class="number">50</span>);  </div><div class="line">        retry();  </div><div class="line">    &#125;  </div><div class="line">&#125; <span class="keyword">else</span> &#123;  </div><div class="line">    <span class="keyword">if</span> (v.timeout &lt;= now()) &#123;  </div><div class="line">        <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="keyword">true</span>) &#123;  </div><div class="line">            <span class="comment">// extend the timeout for other threads  </span></div><div class="line">            v.timeout += <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>;  </div><div class="line">            memcache.set(key, v, KEY_TIMEOUT * <span class="number">2</span>);  </div><div class="line">  </div><div class="line">            <span class="comment">// load the latest value from db  </span></div><div class="line">            v = db.get(key);  </div><div class="line">            v.timeout = KEY_TIMEOUT;  </div><div class="line">            memcache.set(key, value, KEY_TIMEOUT * <span class="number">2</span>);  </div><div class="line">            memcache.delete(key_mutex);  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            sleep(<span class="number">50</span>);  </div><div class="line">            retry();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="“永远不过期”"><a href="#“永远不过期”" class="headerlink" title="“永远不过期”"></a>“永远不过期”</h3><p>其中”永远不过期”包含两层意思：<br>(1)从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。<br>(2)把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期。<br><img src="/img/mutex_key_2.png" alt="示意图"><br>从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。</p>
<h3 id="资源保护"><a href="#资源保护" class="headerlink" title="资源保护"></a>资源保护</h3><p>可以使用提到了netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。<br><img src="/img/mutex_key_3.png" alt="示意图"></p>
<p>作为一个并发量较大的互联网应用，我们的目标有3个:</p>
<ol>
<li>加快用户访问速度，提高用户体验。</li>
<li>降低后端负载，保证系统平稳。</li>
<li>保证数据“尽可能”及时更新(要不要完全一致，取决于业务，而不是技术。)</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th style="text-align:left">解决方案</th>
<th style="text-align:left">优点</th>
<th style="text-align:left">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">简单分布式锁</td>
<td style="text-align:left">思路简单;保证一致性</td>
<td style="text-align:left">代码复杂度增大;存在死锁的风险;存在线程池阻塞的风险</td>
</tr>
<tr>
<td style="text-align:left">加另外一个过期时间</td>
<td style="text-align:left">保证一致性</td>
<td style="text-align:left">代码复杂度增大;存在死锁的风险;存在线程池阻塞的风险</td>
</tr>
<tr>
<td style="text-align:left">不过期</td>
<td style="text-align:left">异步构建缓存，不会阻塞线程池</td>
<td style="text-align:left">不保证一致性;代码复杂度增大(每个value都要维护一个timekey);占用一定的内存空间(每个value都要维护一个timekey)</td>
</tr>
<tr>
<td style="text-align:left">资源隔离组件hystrix</td>
<td style="text-align:left">hystrix技术成熟，有效保证后端;hystrix监控强大</td>
<td style="text-align:left">部分访问存在降级策略</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      有关于热点缓存的思考以及解决方案
    
    </summary>
    
      <category term="Redis" scheme="https://stefanma.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://stefanma.github.io/tags/Redis/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>什么是区块链</title>
    <link href="https://stefanma.github.io/2017/01/18/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>https://stefanma.github.io/2017/01/18/什么是区块链/</id>
    <published>2017-01-18T10:06:51.000Z</published>
    <updated>2017-04-20T10:14:13.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比特币区块链的工作原理"><a href="#比特币区块链的工作原理" class="headerlink" title="比特币区块链的工作原理"></a>比特币区块链的工作原理</h2><p><img src="/img/blockchain-bitcoin-infographic.jpg" alt="示意图"></p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链是比特币的底层技术，它可以理解为一种公共记账的机制，它并不是一款具体的产品。其基本思想是：通过建立一组互联网上的公共账本，由网络中所有的用户共同在账本上记账与核账，来保证信息的真实性和不可篡改性。而之所以名字叫做”区块”链，顾名思义，是因为区块链存储数据的结构是由网络上一个个”存储区块”组成一根链条，每个区块中包含了一定时间内网络中全部的信息交流数据。随着时间推移，这条链会不断增长。</p>
<p>从数据的角度来看：区块链是一种分布式数据库（或称为分布式共享总账，DistributedShared Ledger），这里的“分布式”不仅体现为数据的分布式存储，也体现为数据的分布式记录（即由系统参与者来集体维护）。简单的说，区块链能实现全球数据信息的分布式记录（可以由系统参与者集体记录，而非由一个中心化的机构集中记录）与分布式存储（可以存储在所有参与记录数据的节点中，而非集中存储于中心化的机构节点中）。</p>
<p>从效果的角度来看：区块链可以生成一套记录时间先后的、不可篡改的、可信任的数据库，这套数据库是去中心化存储且数据安全能够得到有效保证的。</p>
<h2 id="交易-事务-Transactions-和区块-Blocks"><a href="#交易-事务-Transactions-和区块-Blocks" class="headerlink" title="交易/事务(Transactions)和区块(Blocks)"></a>交易/事务(Transactions)和区块(Blocks)</h2><h3 id="交易-事务-Transactions"><a href="#交易-事务-Transactions" class="headerlink" title="交易/事务(Transactions)"></a>交易/事务(Transactions)</h3><p>区块链是一个全局共享的，事务性的数据库。这个网络的每一个人都可以读取其中的记录。如果你想修改这个数据库中的东西，就必须创建一个事务，并得到其他所有人的确认。事务意味着你要做一个修改，要么被完全执行要么一点都没有执行。当你的事务被应用到这个数据库的时候，其他事务不能修改该数据库。<br>举个例子，想象一张表，里面列出了比特币所有账号的余额。当从账户A到账户B的转账请求发生时，这个数据库的事务特性确保从账户A中减掉的金额会被加到账户B上。如果因为某种原因，往账户B增加金额无法进行，那么账户A的金额也不会发生任何变化。<br>此外，一个事务会被发送者（事务的创建者）进行密码学签名。这项措施为数据库的修改增加了访问保护。在上面的比特币例子中，可以确保只有持有账户A密钥的人，才能从该账户向外转账。</p>
<h3 id="区块-Blocks"><a href="#区块-Blocks" class="headerlink" title="区块(Blocks)"></a>区块(Blocks)</h3><p>区块链要解决的一个主要难题，在比特币中被称为“双花攻击”。当网络上出现了两笔交易，都要从一个账户中转出余额时，会发生什么？一个冲突？<br>简单的回答是你不需要关心这个问题。这些交易会被排序并打包成“区块”，然后被所有参与的节点执行和分发。如果两笔交易相互冲突，排序靠后的交易会被拒绝并剔除出区块。<br>这些区块按时间排成一个线性序列。这也正是“区块链”这个词的由来。区块以一个相当规律的时间间隔加入到链上。对于比特币，这个间隔大致是10分钟。而对于以太坊，这个间隔大致是17秒，以太坊对比特币做了改进，相信未来可以做到接近实时转账，就可以运用到实时性要求比较高的商业领域。<br>作为“顺序选择机制”（通常称为“挖矿”）的一部分，一段区块链可能会时不时被回滚。但这种情况只会发生在整条链的末端。回滚涉及的区块越多，其发生的概率越小。所以你的交易可能会被回滚，甚至会被从区块链中删除。但是你等待的越久，这种情况发生的概率就越小。</p>
<h2 id="区块链可以影响大行业"><a href="#区块链可以影响大行业" class="headerlink" title="区块链可以影响大行业"></a>区块链可以影响大行业</h2><p><img src="/img/blockchain-impacting-industries.jpg" alt="示意图"></p>
<p>参考链接：<br>[<a href="http://www.teambitcoin.com/blog/2013/5/18/bitcoin-blockchain-explained-in-infographic" target="_blank" rel="external">http://www.teambitcoin.com/blog/2013/5/18/bitcoin-blockchain-explained-in-infographic</a>]<br>[<a href="https://en.wikipedia.org/wiki/Blockchain" target="_blank" rel="external">https://en.wikipedia.org/wiki/Blockchain</a>]<br>[<a href="https://datafloq.com/read/what-is-the-blockchain-and-why-is-it-so-important/2270" target="_blank" rel="external">https://datafloq.com/read/what-is-the-blockchain-and-why-is-it-so-important/2270</a>]</p>
]]></content>
    
    <summary type="html">
    
      区块链的介绍
    
    </summary>
    
      <category term="Blockchain" scheme="https://stefanma.github.io/categories/Blockchain/"/>
    
    
      <category term="区块链" scheme="https://stefanma.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Blockchain" scheme="https://stefanma.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>中国债券市场</title>
    <link href="https://stefanma.github.io/2017/01/10/%E4%B8%AD%E5%9B%BD%E5%80%BA%E5%88%B8%E5%B8%82%E5%9C%BA/"/>
    <id>https://stefanma.github.io/2017/01/10/中国债券市场/</id>
    <published>2017-01-10T03:36:41.000Z</published>
    <updated>2017-06-27T03:45:48.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中国债券市场分布"><a href="#中国债券市场分布" class="headerlink" title="中国债券市场分布"></a>中国债券市场分布</h2><p><img src="/img/bond_info_1.jpg" alt="示意图"></p>
<h2 id="债券在投资组合中的位置"><a href="#债券在投资组合中的位置" class="headerlink" title="债券在投资组合中的位置"></a>债券在投资组合中的位置</h2><p><img src="/img/bond_info_2.jpg" alt="示意图"></p>
<h2 id="不同国债的异同点"><a href="#不同国债的异同点" class="headerlink" title="不同国债的异同点"></a>不同国债的异同点</h2><p><img src="/img/bond_info_3.jpg" alt="示意图"></p>
<h2 id="记帐式国债的发行"><a href="#记帐式国债的发行" class="headerlink" title="记帐式国债的发行"></a>记帐式国债的发行</h2><p><img src="/img/bond_info_4.jpg" alt="示意图"></p>
]]></content>
    
    <summary type="html">
    
      在做债券项目，对中国的债券市场做些了解
    
    </summary>
    
      <category term="Finance" scheme="https://stefanma.github.io/categories/Finance/"/>
    
    
      <category term="Finance" scheme="https://stefanma.github.io/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>债券分类,术语和债券的含义及特征</title>
    <link href="https://stefanma.github.io/2016/12/27/%E5%80%BA%E5%88%B8%E5%88%86%E7%B1%BB%E5%92%8C%E6%9C%AF%E8%AF%AD/"/>
    <id>https://stefanma.github.io/2016/12/27/债券分类和术语/</id>
    <published>2016-12-27T08:56:24.000Z</published>
    <updated>2017-06-27T03:37:29.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="债券分类"><a href="#债券分类" class="headerlink" title="债券分类"></a>债券分类</h2><h3 id="记账式债券"><a href="#记账式债券" class="headerlink" title="记账式债券"></a>记账式债券</h3><p>记账式债券是指没有实物形态的票券，投资者持有的国债登记于证券账户中，投资者仅取得收据或对账单以证实其所有权的一种国债。在我国，上海证券交易所和深圳证券交易所已为证券投资者建立电脑证券账户，因此，可以利用证券交易所的系统来发行债券。我国近年来通过沪、深交易所的交易系统发行和交易的记账式国债就是这方面的实例。如果投资者进行记账式债券的买卖，就必须在证券交易所设立账户。所以，记账式国债又称无纸化国债。</p>
<h3 id="凭证式国债"><a href="#凭证式国债" class="headerlink" title="凭证式国债"></a>凭证式国债</h3><p>凭证式债券的形式是一种债权人认购债券的收款凭证，而不是债券发行人制定的标准格式的债券。我国近年通过银行系统发行的凭证式国债，券面上不印制票面金额（而是根据认购者的认购额填写实际的缴款金额），是一种国家储蓄债，可记名、挂失，以“凭证式国债收款凭证”记录债权，不能上市流通，从购买之日起计息。在持有期内，持券人如果遇到特殊情况，需要提取现金，可以到购买网点提前兑取。提前兑取时，除偿还本金外，利息按实际持有天数及相应的利率档次计算，经办机构按兑付本金的0.2%收取手续费。</p>
<h3 id="无记名式国债"><a href="#无记名式国债" class="headerlink" title="无记名式国债"></a>无记名式国债</h3><p>无记名式国债是一种票面上不记载债权人姓名或单位名称的债券，通常以实物券形式出现，又称实物券或国库券。实物债券是一种具有标准格式实物券面的债券。在标准格式的债券券面上，一般印有债券面额、债券利率、债券期限、债券发行人全称、还本付息方式等各种债券票面要素。有时，债券利率、债券期限等要素也可以通过公告向社会公布，而不再在债券券面上注明。</p>
<h3 id="储蓄国债"><a href="#储蓄国债" class="headerlink" title="储蓄国债"></a>储蓄国债</h3><p>所谓储蓄国债，是政府面向个人投资者发行、以吸收个人储蓄资金为目的，满足长期储蓄性投资需求的不可流通记名国债品种。</p>
<h3 id="企业债券"><a href="#企业债券" class="headerlink" title="企业债券"></a>企业债券</h3><p>企业债券为中华人民共和国国内具有法人资格的企业为筹集生产与建设资金，依照法定程序发行，约定在一定期限内还本付息的债务凭证。在中国，企业债券泛指各种所有制企业发行的债券。在西方国家，由于只有股份公司才能发行企业债券，企业债券即公司债券，它包括的范围较广，如可转换债券和资产支持证券等。</p>
<h3 id="可转换公司债"><a href="#可转换公司债" class="headerlink" title="可转换公司债"></a>可转换公司债</h3><p>可转换公司债是指发行人依照法定程序发行，在一定期限内依据约定的条件可以转换成股份的公司债券。这种债券享受转换特权，在转换前是公司债形式，转换后相当于增发了股票。可转换公司债兼有债权和股权的双重性质。</p>
<h3 id="金融债券"><a href="#金融债券" class="headerlink" title="金融债券"></a>金融债券</h3><p>金融债券是指银行及非银行金融机构依照法定程序发行并约定在一定期限内还本付息的有价证券。金融机构的资金来源很大部分靠吸收存款，但有时它们为改变资产负债结构或者用于某种特定用途，也有可能发行债券以增加资金来源。</p>
<h3 id="国际债券"><a href="#国际债券" class="headerlink" title="国际债券"></a>国际债券</h3><p>国际债券是一种在国际上直接融通资金的金融工具，是一国政府、金融机构、工商企业或国际性组织为筹集中长期资金而在国外金融市场发行的，以外国货币为面值币种的债券。国际债券的发行者与发行地不在同一个国家，因此债券的债务人和债权人也分属不同的国家。</p>
<h2 id="债券专业术语"><a href="#债券专业术语" class="headerlink" title="债券专业术语"></a>债券专业术语</h2><h3 id="债券面值"><a href="#债券面值" class="headerlink" title="债券面值"></a>债券面值</h3><p>债券面值，是指债券发行时所设定的票面金额，它代表着发行人借入并承诺于未来某一特定日期（如债券到期日），偿付给债券持有人的金额。<br>当然，债券面值和投资者购买国债而借给债券发行人的总金额是不同的。实际上，这是投资债券的本金而不是债券面值。<br>目前，我国发行的债券，一般是每张面额为100元，10 000元的本金就可以买10张债券（这种情况出现只适用于平价发行，溢价发行和折价发行则另作别论。三种发行价格之间的区别将在下一章专门讨论）。这里的”每张面额100元”，就可以理解为债券的面值。在进行债券交易时，通过统计某种债券交易的数量，可以清楚地表明债券的交易金额。<br>在债券的票面价值中，首先要规定票面价值的币种，即以何种货币作为债券价值的计量标准。确定币种主要考虑债券的发行对象。一般来说，在国内发行的债券通常以本国本位货币作为面值的计量单位；在国际金融市场筹资，则通常以债券发行地所在国家或地区的货币或以国际上通用的货币为计量标准。<br>此外，确定币种还应考虑债券发行者本身对币种的需要。币种确定后，还要规定债券的票面金额。票面金额的大小不同，可以适应不同的投资对象，同时也会产生不同的发行成本。票面金额定得较小，有利于小额投资者购买，持有者分布面广，但债券本身的印刷及发行工作量大，费用可能较高；票面金额定得较大，有利于少数大额投资者认购，且印刷费用等也会相应减少，但却使小额投资者无法参与。因此，债券票面金额的确定，也要根据债券的发行对象、市场资金供给情况及债券发行费用等因素综合考虑。</p>
<h3 id="净价交易"><a href="#净价交易" class="headerlink" title="净价交易"></a>净价交易</h3><p>净价交易，是指债券现券买卖时，以不含应计利息的价格报价并成交的交易方式，即债券持有期已计利息不计入报价和成交价格中。在进行债券现券交易清算时，买入方除按净价计算的成交价款向卖方支付外，还要向卖方支付应计利息，在债券结算交割单中债券交易净价和应计利息分别列示。目前债券净价交易采取一步到位的办法，即交易系统直接实行净价报价，同时显示债券成交价格和应计利息额，并以两项之和为债券买卖价格；结算系统直接实行净价结算，以债券成交价格与应计利息额之和为债券结算交割价格。净价=全价-应计利息。</p>
<h3 id="全价"><a href="#全价" class="headerlink" title="全价"></a>全价</h3><p>目前的银行间债券市场和交易所债券市场都实行净价交易。在净价交易下，现券买卖交易时，以不含应计利息的价格（净价）报价和成交，而在结算时，再采用全价价格，也就是买方除按净价支付成交价款外，还要另向卖方支付应计利息，净价和利息这两项在交割单中分别列示，以便于国债交易的税务处理。全价、净价和应计利息三者关系如下： 全价=净价+应计利息，亦即：结算价格=成交价格+应计利息。</p>
<h3 id="债券期限"><a href="#债券期限" class="headerlink" title="债券期限"></a>债券期限</h3><p>债券的期限即在债券发行时就确定的债券还本的年限，债券的发行人到期必须偿还本金，债券持有人到期收回本金的权利得到法律的保护。债券按期限的长短可分为长期债券 . 中期债券和短期债券。长期债券期限在 10 年以上，短期债券期限一般在 1 年以内，中期债券的期限则介于二者之间。债券的期限越长，则债券持有者资金周转越慢，在银行利率上升时有可能使投资收益受到影响。债券的期限越长，债券的投资风险也越高，因此要求有较高的收益作为补偿，而收益率高的债券价格也高。所以，为了获取与所遭受的风险相对称的收益，债券的持有人当然对期限长的债券要求较高的收益率，因而长期债券价格一般要高于短期债券的价格。</p>
<h3 id="剩余期限"><a href="#剩余期限" class="headerlink" title="剩余期限"></a>剩余期限</h3><p>剩余期限是指债券距离最终还本付息还有多长时间，一般以年为计算单位，其计算公式如下：剩余期限=（债券最终到期日-交易日）÷365</p>
<h3 id="票面利率"><a href="#票面利率" class="headerlink" title="票面利率"></a>票面利率</h3><p>债券的票面利率即债券券面上所载明的利率，在债券到期以前的整个时期都按此利率计算和支付债息。在银行存款利息率不变的前提下，债券的票面利率越高，则债券持有人所获得的债息就越多，所以债券价格也就越高。反之，则越低。</p>
<h3 id="应计天数"><a href="#应计天数" class="headerlink" title="应计天数"></a>应计天数</h3><p>起息日或上一理论付息日至结算日的实际天数。</p>
<h3 id="应计利息"><a href="#应计利息" class="headerlink" title="应计利息"></a>应计利息</h3><p>应计利息是指自上一利息支付日至买卖结算日产生的利息收入，具体而言，零息债券是指发行起息日至交割日所含利息金额；附息债券是指本付息期起息日至交割日所含利息金额；贴现债券没有票面利率，其应计利息额设为零。应计利息的计算公式如下（以每百元债券所含利息额列示）： 应计利息额=票面利率÷365×已计息天数×100</p>
<h3 id="到期收益率"><a href="#到期收益率" class="headerlink" title="到期收益率"></a>到期收益率</h3><p>到期收益率（YTM[Yield to Maturity]）是使债券上得到的所有回报的现值与债券当前价格相等的收益率。它反映了投资者如果以既定的价格投资某个债券，那么按照复利的方式，得到未来各个时期的货币收入的收益率是多少。</p>
<h3 id="持有期收益率"><a href="#持有期收益率" class="headerlink" title="持有期收益率"></a>持有期收益率</h3><p>持有期收益率是指从购入到卖出这段特有期限里所能得到的收益率。持有期收益率和到期收益率的差别在于将来值的不同。</p>
<h3 id="修正持久期"><a href="#修正持久期" class="headerlink" title="修正持久期"></a>修正持久期</h3><p>修正持久期是衡量价格对收益率变化的敏感度的指标。在市场利率水平发生一定幅度波动时，修正持久期越大的债券，价格波动越大（按百分比计）。</p>
<h3 id="凸性"><a href="#凸性" class="headerlink" title="凸性"></a>凸性</h3><p>是对债券价格利率敏感性的二阶估计，是对债券久期利率敏感性的测量。在价格-收益率出现大幅度变动时，它们的波动幅度呈非线性关系。由持久期作出的预测将有所偏离。凸性就是对这个偏离的修正。无论收益率是上升还是下降，凸性所引起的修正都是正的。因此如果修正持久期相同，凸性越大越好。</p>
<h2 id="债券有四个方面的含义"><a href="#债券有四个方面的含义" class="headerlink" title="债券有四个方面的含义"></a>债券有四个方面的含义</h2><p>发行人是借入资金的经济主体；投资者是出借资金的经济主体；发行人需要在一定时期还本付息；反映了发行者和投资者之间的债权债务关系，而且是这一关系的法律凭证。</p>
<h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><h4 id="债券属于有价证券"><a href="#债券属于有价证券" class="headerlink" title="债券属于有价证券"></a>债券属于有价证券</h4><p>一方面，债券反映和代表一定的价值。债券本身有一定的面值，通常它是债券投资者投入资金的量化表现。同时，持有债券可按期取得利息，利息也是债券投资者收益的价值表现。另一方面，债券与其代表的权利联系在一起，拥有债券也就拥有了债券所代表的权利，转让债券也就将债券代表的权利一并转移。</p>
<h4 id="债券是一种虚拟资本债券"><a href="#债券是一种虚拟资本债券" class="headerlink" title="债券是一种虚拟资本债券"></a>债券是一种虚拟资本债券</h4><p>尽管债券有面值，代表了一定的财产价值，但它也只是一种虚拟资本，而非真实资本。因为债券的本质是证明债权债务关系的证书，在债权债务关系建立时所投入的资金已被债务人占用，因此，债券是实际运用的真实资本的证书。债券的流动并不意味着它所代表的实际资本也同样流动，且债券是独立于实际资本之外的。</p>
<h4 id="债券是债权的表现"><a href="#债券是债权的表现" class="headerlink" title="债券是债权的表现"></a>债券是债权的表现</h4><p>债券代表债券投资者的权利，这种权利不是直接支配财产，也不以资产所有权表现，而是一种债权。拥有债券的人是债权人，债权人不同于财产所有人。以公司为例，在某种意义上，财产所有人可以视作公司的内部构成分子，而债权人是与公司相对立的。债权人除了按期取得本息外，对债务人不能做其他任何干预。</p>
]]></content>
    
    <summary type="html">
    
      项目中要做债券项目，先对一些债券的概念做些了解
    
    </summary>
    
      <category term="Finance" scheme="https://stefanma.github.io/categories/Finance/"/>
    
    
      <category term="Finance" scheme="https://stefanma.github.io/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性简述</title>
    <link href="https://stefanma.github.io/2016/10/12/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AE%80%E8%BF%B0/"/>
    <id>https://stefanma.github.io/2016/10/12/Java8新特性简述/</id>
    <published>2016-10-12T09:17:02.000Z</published>
    <updated>2017-06-26T11:08:37.596Z</updated>
    
    <content type="html"><![CDATA[<p>Java8已经公布了比较长的一段时间，在项目中应用的比较多，接下来对Java8在项目中常应用到的一些特性做比较简要的概述。</p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>到目前为止，空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<br>代码样例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">    <span class="comment">//创建Optional实例，也可以通过方法返回值得到。</span></div><div class="line">    Optional&lt;String&gt; name = Optional.of(<span class="string">"Optional string value"</span>);</div><div class="line">    <span class="comment">//创建没有值的Optional实例，例如值为'null'</span></div><div class="line">    Optional empty = Optional.ofNullable(<span class="keyword">null</span>);</div><div class="line">    <span class="comment">//isPresent方法用来检查Optional实例是否有值。</span></div><div class="line">    <span class="keyword">if</span> (name.isPresent()) &#123;</div><div class="line">        <span class="comment">//调用get()返回Optional值。</span></div><div class="line">        System.out.println(name.get());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//在Optional实例上调用get()抛出NoSuchElementException。</span></div><div class="line">        System.out.println(empty.get());</div><div class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException ex) &#123;</div><div class="line">        System.out.println(ex.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果Optional值不为空，lambda表达式会处理并在其上执行操作。</span></div><div class="line">    name.ifPresent((value) -&gt; &#123;</div><div class="line">        System.out.println(<span class="string">"The length of the value is: "</span> + value.length());</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//如果有值orElse方法会返回Optional实例，否则返回传入的错误信息。</span></div><div class="line">    System.out.println(empty.orElse(<span class="string">"empty.orElse, There is no value present!"</span>));</div><div class="line">    System.out.println(name.orElse(<span class="string">" name.orElse, There is some value!"</span>));</div><div class="line"></div><div class="line">    <span class="comment">//orElseGet与orElse类似，区别在于传入的默认值。</span></div><div class="line">    <span class="comment">//orElseGet接受lambda表达式生成默认值。</span></div><div class="line">    System.out.println(empty.orElseGet(() -&gt; <span class="string">"empty.orElseGet,Default Value"</span>));</div><div class="line">    System.out.println(name.orElseGet(() -&gt; <span class="string">"name.orElseGet,Default Value"</span>));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//filter方法检查给定的Option值是否满足某些条件。</span></div><div class="line">    <span class="comment">//如果满足则返回同一个Option实例，否则返回空Optional。</span></div><div class="line">    Optional&lt;String&gt; longName = name.filter((value) -&gt; value.length() &gt; <span class="number">26</span>);</div><div class="line">    System.out.println(longName.orElse(<span class="string">"The name is less than 26 characters"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1）of方法通过工厂方法创建Optional类。需要注意的是，创建对象时传入的参数不能为null。如果传入参数为null，则抛出NullPointerException 。<br>2）ofNullable与of方法相似，唯一的区别是可以接受参数为null的情况。<br>3）isPresent如果值存在返回true，否则返回false。<br>4）get方法用来得到Optional实例中的值。下面我们看一个抛出NoSuchElementException。<br>5）ifPresent方法，首先需要了解Consumer类。简答地说，Consumer类包含一个抽象方法。该抽象方法对传入的值进行处理，但没有返回值。<br>6）orElse如果有值则将其返回，否则返回指定的其它值。<br>7）orElseGet与orElse方法类似，区别在于得到的默认值。orElse方法将传入的字符串作为默认值，orElseGet方法可以接受Supplier接口的实现用来生成默认值。<br>8）map方法用来对Optional实例的值执行一系列操作。通过一组实现了Function接口的lambda表达式传入操作。<br>9）flatMap如果有值，为其执行mapping函数返回Optional类型返回值，否则返回空Optional。flatMap与map（Funtion）方法类似，区别在于flatMap中的mapper返回值必须是Optional。调用结束时，flatMap不会对结果用Optional封装。<br>10）filter如果有值并且满足断言条件返回包含该值的Optional，否则返回空Optional。</p>
<p>官方文档：<br><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="external">http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html</a></p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>添加的Stream API（java.util.stream）把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，Stream 会隐式地在内部进行遍历，做出相应的数据转换。<br>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br>Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架来拆分任务和加速处理过程。<br>当使用一个流的时候，通常包括三个基本步骤：<br>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。<br><img src="/img/java8-stream_0.png" alt="示意图"></p>
<p>相关文档：<br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></p>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>简单的来讲，Lambda表达式是一个能够被传递的匿名函数。允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>Java 8 lambda表达式的语法：<br>(params) -&gt; expression<br>(params) -&gt; statement<br>(params) -&gt; { statements }</p>
<h3 id="使用Lambda表达式进行事件处理"><a href="#使用Lambda表达式进行事件处理" class="headerlink" title="使用Lambda表达式进行事件处理"></a>使用Lambda表达式进行事件处理</h3><p>可以用lambda表达式写出更好的事件监听代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 8之前：</span></div><div class="line">JButton show =  <span class="keyword">new</span> JButton(<span class="string">"Show"</span>);</div><div class="line">show.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"Event handling without lambda expression is boring"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// Java 8方式：</span></div><div class="line">show.addActionListener((e) -&gt; &#123;</div><div class="line">    System.out.println(<span class="string">"Light, Camera, Action !! Lambda expressions Rocks"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="使用Lambda表达式对列表进行迭代"><a href="#使用Lambda表达式对列表进行迭代" class="headerlink" title="使用Lambda表达式对列表进行迭代"></a>使用Lambda表达式对列表进行迭代</h3><p>针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。<br>可以看到列表现在有了一个 forEach()方法，它可以迭代所有对象，并将你的lambda代码应用在其中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Java 8之前：</span></div><div class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Default Method"</span>, <span class="string">"Stream API"</span>, <span class="string">"Date and Time API"</span>);</div><div class="line"><span class="keyword">for</span> (String feature : features) &#123;</div><div class="line">    System.out.println(feature);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Java 8之后：</span></div><div class="line">List features = Arrays.asList(<span class="string">"Lambdas"</span>, <span class="string">"Default Method"</span>, <span class="string">"Stream API"</span>, <span class="string">"Date and Time API"</span>);</div><div class="line">features.forEach(n -&gt; System.out.println(n));</div><div class="line"> </div><div class="line"><span class="comment">// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，</span></div><div class="line">features.forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<p>列表循环的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。</p>
<h3 id="使用Lambda表达式和函数式接口Predicate"><a href="#使用Lambda表达式和函数式接口Predicate" class="headerlink" title="使用Lambda表达式和函数式接口Predicate"></a>使用Lambda表达式和函数式接口Predicate</h3><p>Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。<br>Predicate接口非常适用于做过滤：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(args[])</span></span>&#123;</div><div class="line">    List languages = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"C++"</span>, <span class="string">"Haskell"</span>, <span class="string">"Lisp"</span>);</div><div class="line"> </div><div class="line">    System.out.println(<span class="string">"Languages which starts with J :"</span>);</div><div class="line">    filter(languages, (str)-&gt;str.startsWith(<span class="string">"J"</span>));</div><div class="line"> </div><div class="line">    System.out.println(<span class="string">"Languages which ends with a "</span>);</div><div class="line">    filter(languages, (str)-&gt;str.endsWith(<span class="string">"a"</span>));</div><div class="line"> </div><div class="line">    System.out.println(<span class="string">"Print all languages :"</span>);</div><div class="line">    filter(languages, (str)-&gt;<span class="keyword">true</span>);</div><div class="line"> </div><div class="line">    System.out.println(<span class="string">"Print no language : "</span>);</div><div class="line">    filter(languages, (str)-&gt;<span class="keyword">false</span>);</div><div class="line"> </div><div class="line">    System.out.println(<span class="string">"Print language whose length greater than 4:"</span>);</div><div class="line">    filter(languages, (str)-&gt;str.length() &gt; <span class="number">4</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Java 8之前：</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate condition)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>(String name: names)  &#123;</div><div class="line">        <span class="keyword">if</span>(condition.test(name)) &#123;</div><div class="line">            System.out.println(name + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 更好的办法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List names, Predicate condition)</span> </span>&#123;</div><div class="line">    names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; &#123;</div><div class="line">        System.out.println(name + <span class="string">" "</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用Lambda表达式的Map和Reduce"><a href="#使用Lambda表达式的Map和Reduce" class="headerlink" title="使用Lambda表达式的Map和Reduce"></a>使用Lambda表达式的Map和Reduce</h3><p>map将集合类（例如列表）元素进行转换的。还有一个 reduce()函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg()或者 count()的聚集函数，实际上就是reduce操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum()的内建方法来做reduce 操作，也有mapToLong()、mapToDouble()方法来做转换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为每个订单加上12%的税</span></div><div class="line"><span class="comment">// 老方法：</span></div><div class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</div><div class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (Integer cost : costBeforeTax) &#123;</div><div class="line">    <span class="keyword">double</span> price = cost + .<span class="number">12</span>*cost;</div><div class="line">    total = total + price;</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"Total : "</span> + total);</div><div class="line"> </div><div class="line"><span class="comment">// 新方法：</span></div><div class="line">List costBeforeTax = Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</div><div class="line"><span class="keyword">double</span> bill = costBeforeTax.stream().map((cost) -&gt; cost + .<span class="number">12</span>*cost).reduce((sum, cost) -&gt; sum + cost).get();</div><div class="line">System.out.println(<span class="string">"Total : "</span> + bill);</div></pre></td></tr></table></figure></p>
<h3 id="过滤创建一个String列表"><a href="#过滤创建一个String列表" class="headerlink" title="过滤创建一个String列表"></a>过滤创建一个String列表</h3><p>过滤在大规模集合上的一个常用操作，而现在使用lambda表达式和流API过滤大规模数据集合是惊人的简单。流提供了一个 filter() 方法，接受一个 Predicate 对象，即可以传入一个lambda表达式作为过滤逻辑。下面的例子是用lambda表达式过滤Java集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个字符串列表，每个字符串长度大于2</span></div><div class="line">List&lt;String&gt; filtered = strList.stream().filter(x -&gt; x.length()&gt; <span class="number">2</span>).collect(Collectors.toList());</div><div class="line">System.out.printf(<span class="string">"Original List : %s, filtered list : %s %n"</span>, strList, filtered);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      Java8比较常用的新特性
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（五）</title>
    <link href="https://stefanma.github.io/2016/09/24/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/24/死磕并发-并发程序设计模式（五）/</id>
    <published>2016-09-24T06:51:51.000Z</published>
    <updated>2017-04-14T07:53:25.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>生产者-消费者模式是一个经典的多线程设计模式，它为多线程之间的协作提供了良好的解决方案。在生产者-消费者模式中，通过两类线程，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程则负责处理生产者提交的任务。生产者和消费者之间通过共享内存缓冲区进行通讯。</p>
<h3 id="生产者-消费者模式架构图"><a href="#生产者-消费者模式架构图" class="headerlink" title="生产者-消费者模式架构图"></a>生产者-消费者模式架构图</h3><p><img src="/img/productor-customer_0.png" alt="模式示意图"></p>
<blockquote>
<p>生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间共享，此外，通过缓冲区可以缓解生产者和消费者性能差。</p>
</blockquote>
<p>生产者-消费者模式的核心组件是共享内存缓存区，它作为生产者和消费者间的通信桥梁，避免了生产者和消费者的直接通信，从而将生产者和消费者进行解耦。生产者不需要知道消费者的存在，消费者也不知道生产者的存在。同时，由于内存缓冲区的存在，允许生产者和消费者在执行速度上存在时间差，无论是生产者在某一个局部时间内速度高于消费者，或是消费者在局部时间内高于生产者，都可以通过内存缓冲区得到缓解，确保系统正常运行。</p>
<p><img src="/img/productor-customer_1.png" alt="模式示意图"></p>
]]></content>
    
    <summary type="html">
    
      生产者-消费者模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（四）</title>
    <link href="https://stefanma.github.io/2016/09/23/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/23/死磕并发-并发程序设计模式（四）/</id>
    <published>2016-09-23T12:28:47.000Z</published>
    <updated>2017-04-14T06:45:23.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h2><p>当多线程对同一个对象进行读写操作时，为了保证对象数据的一致性和正确性，有必要对对象进行同步。而同步操作对系统性能有相当的损耗。为了尽可能的去除这些同步操作，并提高并行程序性能，可以使用一种不可改变的对象，依靠对象的不变形，可以确保其在同步操作的多线程环境中依然保持内部状态的一致性和正确性。</p>
<p>不变模式天生就是多线程有好的，它的核心思想是，一个对象一旦被创建，则它的内部状态永远不会发生改变。所以，没有一个线程可以修改其内部状态和数据，同时其内部的状态绝不会发生改变。基于这些特性，对不变对象的多线程操作不需要进行同步控制。</p>
<p>同时需要注意，不变模式和只读属性是有一定的区别的。不变模式比只读属性具有更强的一致性和不变性。对只读属性的对象而言，对象本身不能被其他线程修改，但是对象自身状态却可能自行修改。</p>
<blockquote>
<p>一个对象的存活时间（对象的创建时间和当前时间的时间差）是只读的，因为任何一个第三方线程都不能修改这个属性，但是这是一个可变的属性，因为随着时间推移，存活时间时刻发生变化。而不变模式要求，无论出于什么原因，对象自建以后，其内部的状态和数据保持绝对的稳定。</p>
</blockquote>
<p>不变模式的主要的使用的场景满足以下两个条件：</p>
<p><1>当对象创建后，其内部状态和数据不再发生任何变化。</1></p>
<p><2>对象需要被共享、被多线程频繁访问。</2></p>
<h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//确保无子类</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductPoJo</span> </span>&#123;</div><div class="line">	<span class="comment">//私有属性，不被其他对象获取</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer id;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> price;</div><div class="line">	<span class="comment">//创建对象时，必须指定数据，创建之后，无法进行修改</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProductPoJo</span><span class="params">(Integer id, String name, <span class="keyword">double</span> price)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.price = price;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> price;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不变模式中的实现中，final关键字起到了重要关键作用。对Class的final定义保证了不变类没有子类，确保所有的getter行为不会被修改。对属性的final定义确保所有的数据只能在对象的被构造时赋值1次，之后，就永远不再发生改变。</p>
<blockquote>
<p>不变模式通过回避问题而不是解决问题的态度来处理多线程并发访问。不变对象是不需要进行同步操作的。由于并发同步会对性能产生不良的影响，因此，在需求允许的情况下，不变模式可以提高系统的并发性能和并发量。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      并发程序的不变模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（三）</title>
    <link href="https://stefanma.github.io/2016/09/23/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/23/死磕并发-并发程序设计模式（三）/</id>
    <published>2016-09-23T09:53:10.000Z</published>
    <updated>2017-04-13T12:30:22.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h2><p>设想一个场景，服务器可能在短时间内承受大量的客户端的请求，客户端的请求数量已经超过了服务器本身的即时处理能力，而服务端又不能丢失任何一个客户请求。此时最佳的方案莫过于就是让客户端的请求进行排队，有服务端一个接一个的处理，这样即可以保证客户端所有的请求均不丢失，同时也避免服务器由于同时处理太多的请求而崩溃。<br>Guarded Suspension解释为保护暂停，核心的思想是仅当服务端进程准备好时，才会提供服务。</p>
<h2 id="Guarded-Suspension的理解和实现"><a href="#Guarded-Suspension的理解和实现" class="headerlink" title="Guarded Suspension的理解和实现"></a>Guarded Suspension的理解和实现</h2><h3 id="Guarded-Suspension模式的结构"><a href="#Guarded-Suspension模式的结构" class="headerlink" title="Guarded Suspension模式的结构"></a>Guarded Suspension模式的结构</h3><p>Request对象封装了客户端的请求。RequestQueue表示客户端的请求队列，由ClientThread和ServerThread共同维护。其中，ClientThread负责不断的发送请求，并将请求对象放入请求队列中。ServerThread根据自身状态，在有能力的处理请求时，从RequestQueue中提取请求对象加以处理。<br>工作流程图如下：<br><img src="/img/guarded-suspension_0.png" alt="示意图"></p>
<blockquote>
<p>Guarded Suspension模式可以确保系统仅有在有能力处理某个任务时，才会处理该任务。当系统没有能力处理任务时，它会暂存任务信息等待系统空闲。</p>
</blockquote>
<h3 id="Guarded-Suspension模式的实现"><a href="#Guarded-Suspension模式的实现" class="headerlink" title="Guarded Suspension模式的实现"></a>Guarded Suspension模式的实现</h3><p><1>RequestPoJo类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestPoJo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RequestPoJo</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"RequestPoJo [name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></1></p>
<p><2>RequestQueue类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> LinkedList&lt;RequestPoJo&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RequestPoJo <span class="title">getRequest</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//等到新的Request加入</span></div><div class="line">		<span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> (RequestPoJo) queue.remove();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addRequest</span><span class="params">(RequestPoJo request)</span></span>&#123;</div><div class="line">		<span class="comment">//添加Request</span></div><div class="line">		queue.add(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></2></p>
<p><3>ClientThread类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> RequestQueue requestQueue;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue requestQueue, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			RequestPoJo request = <span class="keyword">new</span> RequestPoJo(<span class="string">"Request ID"</span>+i+<span class="string">"Thread_name:"</span>+Thread.currentThread().getName());</div><div class="line">			requestQueue.addRequest(request);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">10</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" request end."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></3></p>
<p><4>ServerThread类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue requestQueue, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			RequestPoJo request = requestQueue.getRequest();</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">2000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" handles,"</span>+request);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></4></p>
<blockquote>
<p>Guarded Suspension模式可以在一定程度上环节系统的压力，它可以将系统的负载在时间轴上均匀的分配，有效的降低系统的瞬时负载，对提高系统的抗压力和稳定性有一定的帮助。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      并发程序的Guarded Suspension模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（二）</title>
    <link href="https://stefanma.github.io/2016/09/22/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/22/死磕并发-并发程序设计模式（二）/</id>
    <published>2016-09-22T07:31:04.000Z</published>
    <updated>2017-04-13T12:30:11.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h2><p>Master-Worker模式是常用的并发模式之一。中心就是，系统中有两类进程协调工作，Master进程和Worker进程，Master负责接收和分配任务，Worker负责处理子任务，当各个子任务处理完毕后，将结果返回给Master进程，Master进行归纳和汇总，得到系统的最终结果。<br>处理过程如下：<br><img src="/img/master-worker_0.png" alt="示意图"></p>
<p>Master-Worker模式的好处能够将一个大任务分解成若干的小任务执行，并行执行，提高系统的吞吐量。任务一旦提交，Master进程就会分配任务并立即返回，并不会等待系统全部处理完成后再返回，其处理过程是异步的。因此，Client不会出现等待的现象。</p>
<h2 id="Master-Worker理解和实现"><a href="#Master-Worker理解和实现" class="headerlink" title="Master-Worker理解和实现"></a>Master-Worker理解和实现</h2><h3 id="Master-Worker模式结构"><a href="#Master-Worker模式结构" class="headerlink" title="Master-Worker模式结构"></a>Master-Worker模式结构</h3><p>Master-Worker模式结构相对比较简单。Master进程为主要进程，维护一个<code>Worker进程队列、子任务队列和子结果集</code>。Worker进程队列中的Worker进程，不停的从任务队列中提取要处理的子任务，并将子任务的结果写入结果集中。<br><img src="/img/master-worker_1.png" alt="示意图"></p>
<h3 id="Master-Worker模式简单的代码实现"><a href="#Master-Worker模式简单的代码实现" class="headerlink" title="Master-Worker模式简单的代码实现"></a>Master-Worker模式简单的代码实现</h3><p><1>Master的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//任务队列</span></div><div class="line">	<span class="keyword">protected</span> Queue&lt;Object&gt; workQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</div><div class="line">	<span class="comment">//Work进程队列</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Thread&gt; threadMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	<span class="comment">//子任务处理结果集</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//是否所有的子任务都结束了</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Thread&gt; entry : threadMap.entrySet()) &#123;</div><div class="line">			<span class="keyword">if</span> (entry.getValue().getState() != Thread.State.TERMINATED) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//构造Master，</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(Worker worker, <span class="keyword">int</span> counrWorker)</span></span>&#123;</div><div class="line">		worker.setWorkQueue(workQueue);</div><div class="line">		worker.setResultMap(resultMap);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counrWorker; i++) &#123;</div><div class="line">			threadMap.put(Integer.toString(i), <span class="keyword">new</span> Thread(worker,Integer.toString(i)));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//提交一个任务</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Object task)</span></span>&#123;</div><div class="line">		workQueue.add(task);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//运行Woker进程，进行处理</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Thread&gt; entry : threadMap.entrySet()) &#123;</div><div class="line">			entry.getValue().start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//获取结果集</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getResultMap</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> resultMap;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></1></p>
<p><2>Worker的实现以及子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="comment">//任务队列，获取子任务</span></div><div class="line">	<span class="keyword">protected</span> Queue&lt;Object&gt; workQueue;</div><div class="line">	<span class="comment">//子任务处理的结果集</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Object&gt; resultMap;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkQueue</span><span class="params">(Queue&lt;Object&gt; workQueue)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultMap</span><span class="params">(Map&lt;String, Object&gt; resultMap)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.resultMap = resultMap;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//子任务处理逻辑，可以用于子类的实现具体逻辑</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object input)</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> input;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//获取子任务</span></div><div class="line">			Object input = workQueue.poll();</div><div class="line">			<span class="keyword">if</span> (input == <span class="keyword">null</span> ) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//处理子任务</span></div><div class="line">			Object res = handle(input);</div><div class="line">			<span class="comment">//结果写入结果集</span></div><div class="line">			resultMap.put(Integer.toString(input.hashCode()), res);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></2></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object input)</span> </span>&#123;</div><div class="line">		Integer d = (Integer)input;</div><div class="line">		<span class="keyword">return</span> d*d*d;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><3>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算1--100的立方的和</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Master master = <span class="keyword">new</span> Master(<span class="keyword">new</span> PlusWorker(), <span class="number">5</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</div><div class="line">			master.submit(i);</div><div class="line">		&#125;</div><div class="line">		master.execute();</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">		Map&lt;String, Object&gt; resultMap = master.getResultMap();</div><div class="line">		<span class="keyword">while</span> (resultMap.size() &gt;<span class="number">0</span> || !master.isComplete()) &#123;</div><div class="line">			Set&lt;String&gt; keys = resultMap.keySet();</div><div class="line">			String key = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">for</span> (String k:keys) &#123;</div><div class="line">				key = k;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			Integer i=<span class="keyword">null</span>;</div><div class="line">			<span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">				i = (Integer) resultMap.get(key);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</div><div class="line">				res+=i;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">				resultMap.remove(key);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"final res="</span>+res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></3></p>
<blockquote>
<p>Master-Worker模式是一种将任务串行化的方案，被分解的子任务在系统中可以并行的处理。同时，如果需要，Master进程不需要等待所有的子任务都完成计算，就可以根据已有的部分结果集计算最终结果。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      并发程序的Master-Worker模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（一）</title>
    <link href="https://stefanma.github.io/2016/09/20/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/20/死磕并发-并发程序设计模式（一）/</id>
    <published>2016-09-20T09:30:25.000Z</published>
    <updated>2017-04-13T10:02:17.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>对于Future模式有点像期货市场的“期货”，是“对未来的一种凭证”；例如：我在期货交易中心买了期货，交钱之后，会拿到一个期货的凭证，这个凭证告诉我等XXXX年某个时候可以拿这个凭证来拿对方的物品，而现在我是没有办法拿到物品的，需要等到协定的时间来取。<br>对于程序代码来讲，实现了Future模式的客户端在程序处理任务还没有返回结果时，而是去调用了其他业务逻辑的，充分利用等待时间。在完成了对其他业务的处理后，最后再使用返回比较慢的程序数据，在整个调用过程中，就不存在了无所谓的等待，充分利用所有的时间片段，从而提高整个系统的响应速度。</p>
<h2 id="模式流程图"><a href="#模式流程图" class="headerlink" title="模式流程图"></a>模式流程图</h2><p>基本的模式流程图<br><img src="/img/future_model_0.png" alt="模式流程图"></p>
<h2 id="Future模式Java实现"><a href="#Future模式Java实现" class="headerlink" title="Future模式Java实现"></a>Future模式Java实现</h2><p>1.Main函数调用：<br>ApplicationTest主要是client发起请求，并返回数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		ClientMain client = <span class="keyword">new</span> ClientMain();</div><div class="line">		<span class="comment">// 这里会立即返回，因为获取的是FutureData，而非RealData</span></div><div class="line">		Data data = client.request(<span class="string">"name"</span>);</div><div class="line">		System.out.println(<span class="string">"请求完毕！"</span>);  </div><div class="line">		<span class="comment">// 这里可以用一个sleep代替对其他业务逻辑的处理</span></div><div class="line">		<span class="comment">// 在处理这些业务逻辑过程中，RealData也正在创建，从而充分了利用等待时间</span></div><div class="line">		Thread.sleep(<span class="number">2000</span>);</div><div class="line">		<span class="comment">// 使用真实数据</span></div><div class="line">		System.out.println(<span class="string">"数据="</span> + data.getResult());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.ClientMain实现：<br>ClientMain主要实现了FutureData，开启构造RealData的线程，接收请求后很快的返回FutureData。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String string)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> FutureData futureData = <span class="keyword">new</span> FutureData();</div><div class="line">		<span class="comment">// 开启一个新的线程来构造真实数据</span></div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// RealData的构建很慢，所以放在单独的线程中运行</span></div><div class="line">				RealData realData = <span class="keyword">new</span> RealData(string);</div><div class="line">				futureData.setRealData(realData);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		<span class="keyword">return</span> futureData; <span class="comment">// 先直接返回FutureData</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.Data的实现：<br>Data是一个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.FutureData的实现：<br>FutureData实现了一个快速返回的RealData的包装。当使用FutureData的getResult()方法时，程序会阻塞，等待RealData被注入到程序中，才使用RealData的getResult()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//FutureData是Future模式的关键，它实际上是真实数据RealData的代理，封装了获取RealData的等待过程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// FutureData是RealData的封装</span></div><div class="line">	RealData realData = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">// 是否已经准备好</span></div><div class="line">	<span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (isReady)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.realData = realData;</div><div class="line">		isReady = <span class="keyword">true</span>;</div><div class="line">		notifyAll(); <span class="comment">// RealData已经被注入到FutureData中了，通知getResult()方法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (!isReady) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> realData.getResult();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.RealData实现：<br>RealData是最终需要使用的数据模型，构造速度比较慢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span> String data;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String data)</span> </span>&#123;</div><div class="line">    	<span class="comment">//RealData的构建过程可能会很慢，需要用户等很长的时间</span></div><div class="line">    	System.out.println(<span class="string">"RealData data:"</span>+data);</div><div class="line">    	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            	sb.append(<span class="string">"++"</span>+data);</div><div class="line">                Thread.sleep(<span class="number">200</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.data = sb.toString();</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		 <span class="keyword">return</span> data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JDK内置的实现"><a href="#JDK内置的实现" class="headerlink" title="JDK内置的实现"></a>JDK内置的实现</h2><p>在JDK自带的实现中，有关实现Future模式的核心结构如图:<br><img src="/img/future_model_1.png" alt="Future模式的核心结构图"></p>
<p>FutureTask是最为重要的模块，实现了RunnableFuture接口，而RunnableFuture继承Runnable和Future，实现了Runnable的接口，作为单独的线程运行。在run()的方法中维护了Callable，并维护该对象返回的对象。当FutureTask.get()方法时，将返回Callable接口的返回对象。<br><img src="/img/future_model_2.png" alt="JDK代码"></p>
<blockquote>
<p>Future模式的核心是在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑，从而充分的利用计算机资源。</p>
</blockquote>
<h2 id="FutureTask使用场景"><a href="#FutureTask使用场景" class="headerlink" title="FutureTask使用场景"></a>FutureTask使用场景</h2><p>未完待续……</p>
]]></content>
    
    <summary type="html">
    
      并发程序的Future模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
