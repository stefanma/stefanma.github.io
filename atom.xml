<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stefan&#39;s Room</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stefanma.github.io/"/>
  <updated>2017-04-13T12:30:22.639Z</updated>
  <id>https://stefanma.github.io/</id>
  
  <author>
    <name>Stefan Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>死磕并发--并发程序设计模式（三）</title>
    <link href="https://stefanma.github.io/2016/09/23/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/23/死磕并发-并发程序设计模式（三）/</id>
    <published>2016-09-23T09:53:10.000Z</published>
    <updated>2017-04-13T12:30:22.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h2><p>设想一个场景，服务器可能在短时间内承受大量的客户端的请求，客户端的请求数量已经超过了服务器本身的即时处理能力，而服务端又不能丢失任何一个客户请求。此时最佳的方案莫过于就是让客户端的请求进行排队，有服务端一个接一个的处理，这样即可以保证客户端所有的请求均不丢失，同时也避免服务器由于同时处理太多的请求而崩溃。<br>Guarded Suspension解释为保护暂停，核心的思想是仅当服务端进程准备好时，才会提供服务。</p>
<h2 id="Guarded-Suspension的理解和实现"><a href="#Guarded-Suspension的理解和实现" class="headerlink" title="Guarded Suspension的理解和实现"></a>Guarded Suspension的理解和实现</h2><h3 id="Guarded-Suspension模式的结构"><a href="#Guarded-Suspension模式的结构" class="headerlink" title="Guarded Suspension模式的结构"></a>Guarded Suspension模式的结构</h3><p>Request对象封装了客户端的请求。RequestQueue表示客户端的请求队列，由ClientThread和ServerThread共同维护。其中，ClientThread负责不断的发送请求，并将请求对象放入请求队列中。ServerThread根据自身状态，在有能力的处理请求时，从RequestQueue中提取请求对象加以处理。<br>工作流程图如下：<br><img src="/img/guarded-suspension_0.png" alt="示意图"></p>
<blockquote>
<p>Guarded Suspension模式可以确保系统仅有在有能力处理某个任务时，才会处理该任务。当系统没有能力处理任务时，它会暂存任务信息等待系统空闲。</p>
</blockquote>
<h3 id="Guarded-Suspension模式的实现"><a href="#Guarded-Suspension模式的实现" class="headerlink" title="Guarded Suspension模式的实现"></a>Guarded Suspension模式的实现</h3><p><1>RequestPoJo类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestPoJo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RequestPoJo</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"RequestPoJo [name="</span> + name + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></1></p>
<p><2>RequestQueue类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> LinkedList&lt;RequestPoJo&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> RequestPoJo <span class="title">getRequest</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//等到新的Request加入</span></div><div class="line">		<span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> (RequestPoJo) queue.remove();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addRequest</span><span class="params">(RequestPoJo request)</span></span>&#123;</div><div class="line">		<span class="comment">//添加Request</span></div><div class="line">		queue.add(request);</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></2></p>
<p><3>ClientThread类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> RequestQueue requestQueue;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue requestQueue, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			RequestPoJo request = <span class="keyword">new</span> RequestPoJo(<span class="string">"Request ID"</span>+i+<span class="string">"Thread_name:"</span>+Thread.currentThread().getName());</div><div class="line">			requestQueue.addRequest(request);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">10</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" request end."</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></3></p>
<p><4>ServerThread类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> RequestQueue requestQueue;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue requestQueue, String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(name);</div><div class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			RequestPoJo request = requestQueue.getRequest();</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">2000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" handles,"</span>+request);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></4></p>
<blockquote>
<p>Guarded Suspension模式可以在一定程度上环节系统的压力，它可以将系统的负载在时间轴上均匀的分配，有效的降低系统的瞬时负载，对提高系统的抗压力和稳定性有一定的帮助。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      并发程序的Guarded Suspension模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（二）</title>
    <link href="https://stefanma.github.io/2016/09/22/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/22/死磕并发-并发程序设计模式（二）/</id>
    <published>2016-09-22T07:31:04.000Z</published>
    <updated>2017-04-13T12:30:11.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h2><p>Master-Worker模式是常用的并发模式之一。中心就是，系统中有两类进程协调工作，Master进程和Worker进程，Master负责接收和分配任务，Worker负责处理子任务，当各个子任务处理完毕后，将结果返回给Master进程，Master进行归纳和汇总，得到系统的最终结果。<br>处理过程如下：<br><img src="/img/master-worker_0.png" alt="示意图"></p>
<p>Master-Worker模式的好处能够将一个大任务分解成若干的小任务执行，并行执行，提高系统的吞吐量。任务一旦提交，Master进程就会分配任务并立即返回，并不会等待系统全部处理完成后再返回，其处理过程是异步的。因此，Client不会出现等待的现象。</p>
<h2 id="Master-Worker理解和实现"><a href="#Master-Worker理解和实现" class="headerlink" title="Master-Worker理解和实现"></a>Master-Worker理解和实现</h2><h3 id="Master-Worker模式结构"><a href="#Master-Worker模式结构" class="headerlink" title="Master-Worker模式结构"></a>Master-Worker模式结构</h3><p>Master-Worker模式结构相对比较简单。Master进程为主要进程，维护一个<code>Worker进程队列、子任务队列和子结果集</code>。Worker进程队列中的Worker进程，不停的从任务队列中提取要处理的子任务，并将子任务的结果写入结果集中。<br><img src="/img/master-worker_1.png" alt="示意图"></p>
<h3 id="Master-Worker模式简单的代码实现"><a href="#Master-Worker模式简单的代码实现" class="headerlink" title="Master-Worker模式简单的代码实现"></a>Master-Worker模式简单的代码实现</h3><p><1>Master的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//任务队列</span></div><div class="line">	<span class="keyword">protected</span> Queue&lt;Object&gt; workQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</div><div class="line">	<span class="comment">//Work进程队列</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Thread&gt; threadMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	<span class="comment">//子任务处理结果集</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Object&gt; resultMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//是否所有的子任务都结束了</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Thread&gt; entry : threadMap.entrySet()) &#123;</div><div class="line">			<span class="keyword">if</span> (entry.getValue().getState() != Thread.State.TERMINATED) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//构造Master，</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(Worker worker, <span class="keyword">int</span> counrWorker)</span></span>&#123;</div><div class="line">		worker.setWorkQueue(workQueue);</div><div class="line">		worker.setResultMap(resultMap);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counrWorker; i++) &#123;</div><div class="line">			threadMap.put(Integer.toString(i), <span class="keyword">new</span> Thread(worker,Integer.toString(i)));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//提交一个任务</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Object task)</span></span>&#123;</div><div class="line">		workQueue.add(task);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//运行Woker进程，进行处理</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Thread&gt; entry : threadMap.entrySet()) &#123;</div><div class="line">			entry.getValue().start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//获取结果集</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getResultMap</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> resultMap;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></1></p>
<p><2>Worker的实现以及子类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">	<span class="comment">//任务队列，获取子任务</span></div><div class="line">	<span class="keyword">protected</span> Queue&lt;Object&gt; workQueue;</div><div class="line">	<span class="comment">//子任务处理的结果集</span></div><div class="line">	<span class="keyword">protected</span> Map&lt;String, Object&gt; resultMap;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWorkQueue</span><span class="params">(Queue&lt;Object&gt; workQueue)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResultMap</span><span class="params">(Map&lt;String, Object&gt; resultMap)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.resultMap = resultMap;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//子任务处理逻辑，可以用于子类的实现具体逻辑</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object input)</span></span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> input;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">			<span class="comment">//获取子任务</span></div><div class="line">			Object input = workQueue.poll();</div><div class="line">			<span class="keyword">if</span> (input == <span class="keyword">null</span> ) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//处理子任务</span></div><div class="line">			Object res = handle(input);</div><div class="line">			<span class="comment">//结果写入结果集</span></div><div class="line">			resultMap.put(Integer.toString(input.hashCode()), res);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></2></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object input)</span> </span>&#123;</div><div class="line">		Integer d = (Integer)input;</div><div class="line">		<span class="keyword">return</span> d*d*d;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><3>Main方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算1--100的立方的和</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Master master = <span class="keyword">new</span> Master(<span class="keyword">new</span> PlusWorker(), <span class="number">5</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</div><div class="line">			master.submit(i);</div><div class="line">		&#125;</div><div class="line">		master.execute();</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">		Map&lt;String, Object&gt; resultMap = master.getResultMap();</div><div class="line">		<span class="keyword">while</span> (resultMap.size() &gt;<span class="number">0</span> || !master.isComplete()) &#123;</div><div class="line">			Set&lt;String&gt; keys = resultMap.keySet();</div><div class="line">			String key = <span class="keyword">null</span>;</div><div class="line">			<span class="keyword">for</span> (String k:keys) &#123;</div><div class="line">				key = k;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			Integer i=<span class="keyword">null</span>;</div><div class="line">			<span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">				i = (Integer) resultMap.get(key);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</div><div class="line">				res+=i;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</div><div class="line">				resultMap.remove(key);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"final res="</span>+res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></3></p>
<blockquote>
<p>Master-Worker模式是一种将任务串行化的方案，被分解的子任务在系统中可以并行的处理。同时，如果需要，Master进程不需要等待所有的子任务都完成计算，就可以根据已有的部分结果集计算最终结果。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      并发程序的Master-Worker模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（一）</title>
    <link href="https://stefanma.github.io/2016/09/20/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/20/死磕并发-并发程序设计模式（一）/</id>
    <published>2016-09-20T09:30:25.000Z</published>
    <updated>2017-04-13T10:02:17.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>对于Future模式有点像期货市场的“期货”，是“对未来的一种凭证”；例如：我在期货交易中心买了期货，交钱之后，会拿到一个期货的凭证，这个凭证告诉我等XXXX年某个时候可以拿这个凭证来拿对方的物品，而现在我是没有办法拿到物品的，需要等到协定的时间来取。<br>对于程序代码来讲，实现了Future模式的客户端在程序处理任务还没有返回结果时，而是去调用了其他业务逻辑的，充分利用等待时间。在完成了对其他业务的处理后，最后再使用返回比较慢的程序数据，在整个调用过程中，就不存在了无所谓的等待，充分利用所有的时间片段，从而提高整个系统的响应速度。</p>
<h2 id="模式流程图"><a href="#模式流程图" class="headerlink" title="模式流程图"></a>模式流程图</h2><p>基本的模式流程图<br><img src="/img/future_model_0.png" alt="模式流程图"></p>
<h2 id="Future模式Java实现"><a href="#Future模式Java实现" class="headerlink" title="Future模式Java实现"></a>Future模式Java实现</h2><p>1.Main函数调用：<br>ApplicationTest主要是client发起请求，并返回数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		ClientMain client = <span class="keyword">new</span> ClientMain();</div><div class="line">		<span class="comment">// 这里会立即返回，因为获取的是FutureData，而非RealData</span></div><div class="line">		Data data = client.request(<span class="string">"name"</span>);</div><div class="line">		System.out.println(<span class="string">"请求完毕！"</span>);  </div><div class="line">		<span class="comment">// 这里可以用一个sleep代替对其他业务逻辑的处理</span></div><div class="line">		<span class="comment">// 在处理这些业务逻辑过程中，RealData也正在创建，从而充分了利用等待时间</span></div><div class="line">		Thread.sleep(<span class="number">2000</span>);</div><div class="line">		<span class="comment">// 使用真实数据</span></div><div class="line">		System.out.println(<span class="string">"数据="</span> + data.getResult());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.ClientMain实现：<br>ClientMain主要实现了FutureData，开启构造RealData的线程，接收请求后很快的返回FutureData。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String string)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> FutureData futureData = <span class="keyword">new</span> FutureData();</div><div class="line">		<span class="comment">// 开启一个新的线程来构造真实数据</span></div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// RealData的构建很慢，所以放在单独的线程中运行</span></div><div class="line">				RealData realData = <span class="keyword">new</span> RealData(string);</div><div class="line">				futureData.setRealData(realData);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line"></div><div class="line">		<span class="keyword">return</span> futureData; <span class="comment">// 先直接返回FutureData</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.Data的实现：<br>Data是一个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.FutureData的实现：<br>FutureData实现了一个快速返回的RealData的包装。当使用FutureData的getResult()方法时，程序会阻塞，等待RealData被注入到程序中，才使用RealData的getResult()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//FutureData是Future模式的关键，它实际上是真实数据RealData的代理，封装了获取RealData的等待过程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// FutureData是RealData的封装</span></div><div class="line">	RealData realData = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">// 是否已经准备好</span></div><div class="line">	<span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (isReady)&#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.realData = realData;</div><div class="line">		isReady = <span class="keyword">true</span>;</div><div class="line">		notifyAll(); <span class="comment">// RealData已经被注入到FutureData中了，通知getResult()方法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (!isReady) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				wait();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> realData.getResult();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.RealData实现：<br>RealData是最终需要使用的数据模型，构造速度比较慢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span> String data;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String data)</span> </span>&#123;</div><div class="line">    	<span class="comment">//RealData的构建过程可能会很慢，需要用户等很长的时间</span></div><div class="line">    	System.out.println(<span class="string">"RealData data:"</span>+data);</div><div class="line">    	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            	sb.append(<span class="string">"++"</span>+data);</div><div class="line">                Thread.sleep(<span class="number">200</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.data = sb.toString();</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		 <span class="keyword">return</span> data;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="JDK内置的实现"><a href="#JDK内置的实现" class="headerlink" title="JDK内置的实现"></a>JDK内置的实现</h2><p>在JDK自带的实现中，有关实现Future模式的核心结构如图:<br><img src="/img/future_model_1.png" alt="Future模式的核心结构图"></p>
<p>FutureTask是最为重要的模块，实现了RunnableFuture接口，而RunnableFuture继承Runnable和Future，实现了Runnable的接口，作为单独的线程运行。在run()的方法中维护了Callable，并维护该对象返回的对象。当FutureTask.get()方法时，将返回Callable接口的返回对象。<br><img src="/img/future_model_2.png" alt="JDK代码"></p>
<blockquote>
<p>Future模式的核心是在于：去除了主函数的等待时间，并使得原本需要等待的时间段可以用于处理其他业务逻辑，从而充分的利用计算机资源。</p>
</blockquote>
<h2 id="FutureTask使用场景"><a href="#FutureTask使用场景" class="headerlink" title="FutureTask使用场景"></a>FutureTask使用场景</h2><p>未完待续……</p>
]]></content>
    
    <summary type="html">
    
      并发程序的Future模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>死磕并发--并发程序设计模式（四）</title>
    <link href="https://stefanma.github.io/2016/09/13/%E6%AD%BB%E7%A3%95%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://stefanma.github.io/2016/09/13/死磕并发-并发程序设计模式（四）/</id>
    <published>2016-09-13T12:28:47.000Z</published>
    <updated>2017-04-13T12:35:37.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h2><p>当多线程对同一个对象进行读写操作时，为了保证对象数据的一致性和正确性，有必要对对象进行同步。而同步操作对系统性能有相当的损耗。为了尽可能的去除这些同步操作，并提高并行程序性能，可以使用一种不可改变的对象，依靠对象的不变形，可以确保其在同步操作的多线程环境中依然保持内部状态的一致性和正确性。</p>
]]></content>
    
    <summary type="html">
    
      并发程序的不变模式
    
    </summary>
    
      <category term="Java" scheme="https://stefanma.github.io/categories/java/"/>
    
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux查找命令小记</title>
    <link href="https://stefanma.github.io/2016/09/09/Linux%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/"/>
    <id>https://stefanma.github.io/2016/09/09/Linux查找命令小记/</id>
    <published>2016-09-09T07:37:33.000Z</published>
    <updated>2017-03-09T09:02:15.353Z</updated>
    
    <content type="html"><![CDATA[<p><strong>小记</strong><br>在Linux系统中查找文件，定位相关的路径是攻城狮们经常遇到的，Linux就向是一个相当大的仓库，需要及时的准确的找到自己想要的路径和文件，那就需要比较好的搜索工具；搜索工具好不好关系到定位问题的精准和效率。今天在DEV环境需要查找自己很久之前部署的Redis，文件路径由于时间比较久远已经忘记了，怎么精确的快速找到自己部署的应用。经历了一段小的寻找路程，虽然耗时不是那么多的时间，记录下来以便自己和看这篇文章的同学参考。</p>
<h2 id="查找Redis部署路径"><a href="#查找Redis部署路径" class="headerlink" title="查找Redis部署路径"></a>查找Redis部署路径</h2><p>(1)首先我要确保我用的这台服务器上确实有Redis在运行着；<br>查看如下图命令和操作：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# ps -ef|grep redis</div><div class="line">root      5705     1  0  2016 ?        05:32:56 ./redis-server *:6379    </div><div class="line">root     30763 29277  0 16:52 pts/3    00:00:00 grep redis</div><div class="line">[root@vm-test01 /]#</div></pre></td></tr></table></figure></p>
<p>(2)使用find命令<br>查看如下图命令和操作：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# find / -name redis-server</div><div class="line">/home/redis/redis-server</div></pre></td></tr></table></figure></p>
<h2 id="Linux查找命令"><a href="#Linux查找命令" class="headerlink" title="Linux查找命令"></a>Linux查找命令</h2><p><strong>可以使用下面的一些命令来搜索：</strong><br><code>which        查看可执行文件的位置</code><br><code>whereis      查看文件的位置</code><br><code>locate       配合数据库查看文件位置</code><br><code>find         实际搜寻硬盘查询文件名称</code></p>
<h3 id="Linux查找命令详解"><a href="#Linux查找命令详解" class="headerlink" title="Linux查找命令详解"></a>Linux查找命令详解</h3><p>1.which<br>语法: which 可执行文件名称</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]#  which passwd</div><div class="line">/usr/bin/passwd</div></pre></td></tr></table></figure>
<blockquote>
<p>which是通过 PATH环境变量到该路径内查找可执行文件，所以基本的功能是<code>寻找可执行文件</code>.</p>
</blockquote>
<p>2.whereis<br>语法: whereis [-bmsu] 文件或者目录名称<br>参数说明：<br>-b: 只找二进制文件<br>-m: 只找在说明文件manual路径下的文件<br>-s: 只找source源文件<br>-u: 没有说明文档的文件</p>
<p>将和passwd文件相关的文件都查找出来<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]#  whereis passwd</div><div class="line">passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz</div></pre></td></tr></table></figure></p>
<p>只将二进制文件查找出来<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# whereis -b passwd</div><div class="line">passwd: /usr/bin/passwd /etc/passwd</div></pre></td></tr></table></figure></p>
<blockquote>
<p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p>
</blockquote>
<p>3.locate<br>语法: locate 文件或者目录名称</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]#  locate redis</div><div class="line">/home/quartz/webapps/quartz-service/WEB-INF/classes/spring/applicationContext-redis.xml</div><div class="line">/home/redis/dump.rdb</div><div class="line">/home/redis/redis-benchmark</div><div class="line">/home/redis/redis-cli</div><div class="line">/home/redis/redis-server</div><div class="line">/home/redis/redis.conf</div><div class="line">/home/redis/redis.pid</div><div class="line">/home/redis/redis1.conf</div><div class="line">/home/redis/redis_init_script</div><div class="line">/home/redis/temp-12938.rdb</div><div class="line">/home/redis/temp-3575.rdb</div><div class="line">···············</div></pre></td></tr></table></figure>
<p>4.find<br>语法: find 路径 参数<br>参数说明：<br>时间查找参数：<br>-atime n :将n<em>24小时内存取过的的文件列出来<br>-ctime n :将n</em>24小时内改变、新增的文件或者目录列出来<br>-mtime n :将n*24小时内修改过的文件或者目录列出来<br>-newer file :把比file还要新的文件列出来</p>
<p>名称查找参数：<br>-gid n       :寻找群组ID为n的文件<br>-group name  :寻找群组名称为name的文件<br>-uid n       :寻找拥有者ID为n的文件<br>-user name   :寻找用户者名称为name的文件<br>-name file   :寻找文件名为file的文件（可以使用通配符）</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@vm-test01 /]# find / -name redis-server</div><div class="line">/home/redis/redis-server</div></pre></td></tr></table></figure>
<blockquote>
<p>find命令所查找的目录路径，是在硬盘上遍历查找，因此非常消耗硬盘的资源，而且效率也非常低。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Linux查找命令的区别
    
    </summary>
    
      <category term="Linux" scheme="https://stefanma.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://stefanma.github.io/tags/Linux/"/>
    
      <category term="Redis" scheme="https://stefanma.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>让MySQL支持中文排序的实现方法</title>
    <link href="https://stefanma.github.io/2016/09/07/%E8%AE%A9MySQL%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>https://stefanma.github.io/2016/09/07/让MySQL支持中文排序的实现方法/</id>
    <published>2016-09-07T02:57:36.000Z</published>
    <updated>2017-03-10T11:16:25.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="让MySQL支持中文排序"><a href="#让MySQL支持中文排序" class="headerlink" title="让MySQL支持中文排序"></a>让MySQL支持中文排序</h2><p>如果在mysql中使用字符集为utf8，想要对中文字段用order by chinese_field 排序，那么出来的顺序并不是按照拼音排序的，不是我们想要的结果。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="（1）方案一"><a href="#（1）方案一" class="headerlink" title="（1）方案一"></a>（1）方案一</h3><p>对于包含中文的字段加上”binary”属性，使之作为二进制比较，例如将”name char(10)”改成”name char(10)binary”。<br>如果使用源码编译MySQL，可以编译MySQL时使用 –with–charset=gbk 参数，这样MySQL就会直接支持中文查找和排序。也可以用 extra-charsets=gb2312,gbk 来加入多个字符集。</p>
<h3 id="（2）方案二"><a href="#（2）方案二" class="headerlink" title="（2）方案二"></a>（2）方案二</h3><p>可以在查询语句的order by部分使用 CONVERT 函数<br>对中文字段使用gbk编码排序：</p>
<blockquote>
<p>SELECT * FROM table ORDER BY CONVERT(chinese_field USING gbk );</p>
</blockquote>
<p>当然这需要你安装mysql时安装了gbk字符集，不然会报错：#1115 - Unknown character set: ‘gbk’</p>
]]></content>
    
    <summary type="html">
    
      MySQL中文排序方法
    
    </summary>
    
      <category term="MySQL" scheme="https://stefanma.github.io/categories/mysql/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="MySQL" scheme="https://stefanma.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://stefanma.github.io/2016/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://stefanma.github.io/2016/09/04/设计模式之单例模式/</id>
    <published>2016-09-04T02:33:08.000Z</published>
    <updated>2017-03-05T14:50:00.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是项目中的设计模式最普遍使用的模式之一。它是一种对象创建的模式，用于产生一个对象的具体实例，可以确保系统中一个类只产生一个实例。<br>有2大好处：<br>（1）对于频繁使用的对象，可以省略创建对象所花费的时间，对于那些重量级的对象而言，是一笔非常客观的系统开销；<br>（2）由于new的操作次数减少，因而对系统内存的使用频率也会降低，这将会减轻GC的压力，缩短GC停顿的时间；<br>对于系统的关键组件和被频繁使用的对象，使用单例可以有效的改善系统性能。</p>
<h3 id="单例类的角色："><a href="#单例类的角色：" class="headerlink" title="单例类的角色："></a>单例类的角色：</h3><table>
<thead>
<tr>
<th style="text-align:center">角色</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">单例者</td>
<td style="text-align:center">提供单例工厂，返回单例</td>
</tr>
<tr>
<td style="text-align:center">使用者</td>
<td style="text-align:center">获取并使用单例类</td>
</tr>
</tbody>
</table>
<h3 id="单例的实现："><a href="#单例的实现：" class="headerlink" title="单例的实现："></a>单例的实现：</h3><p>单例模式的核心是通过一个接口返回唯一的一个对象实例。一个简单的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Singleton is created.."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先单例类必须有一个private访问级别的构造函数，只有这样，才能保证单例不会被系统中其他代码内被实例化，这一点是相当重要的；其次instance成员变量和getInstance()方法必须是static的。<br>它唯一不足的地方是无法对instance做延迟加载。假如单例的创建过程很慢，而由于instance成员变量是static定义的，因此在JVM加载单例类的时候，单例对象会被创建，如果此时，这个单例类在系统中扮演其他角色，那么在任何使用这个单例类的地方都会初始化这个单例变量，而不管是否被用到。</p>
<p>为了解决这个问题，并以此来提高系统在相关函数调用时的反应速度，就需要加入延迟加载机制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"LazySingleton is created.."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用上例中的单例实现，虽然实现了延迟加载的功能，但是和第一种方法相比，它引入了同步关键字，以此在多线程环境中，它的耗时会远远大于第一种的单例的实现。</p>
<p>为了使用延迟加载而引入同步关键字反而降低了系统性能，是不是有点得不偿失？<br>为了解决这个问题，对其进行改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"StaticSingleton is created.."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton instance = <span class="keyword">new</span> StaticSingleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个实现中，单例模式使用内部类来维护单例的实例，当StaticSingleton被加载时，其内部类不会被初始化，故此可以确保StaticSingleton类被加载到JVM时，不会初始化单例类，而当getInstance()方法被调用时，才会加载SingletonHolder，从而初始化instance，同时，实例的创建是在类加载的时候完成的，故天生对多线程是友好的，getInstance()也不需要加同步关键字。这种方式兼顾以上两种实现的优点。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>使用内部类的方式实现单例，既可以做到延迟加载，也不必使用同步关键字，是一种比较完善的实现。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      单例模式的理解和应用
    
    </summary>
    
      <category term="设计模式" scheme="https://stefanma.github.io/categories/designpattern/"/>
    
    
      <category term="设计模式" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="设计优化" scheme="https://stefanma.github.io/tags/%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁的基本原理</title>
    <link href="https://stefanma.github.io/2016/09/03/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>https://stefanma.github.io/2016/09/03/分布式锁的基本原理/</id>
    <published>2016-09-03T03:27:57.000Z</published>
    <updated>2017-03-05T14:49:48.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。分布式锁，是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往<strong>需要互斥来防止彼此干扰来保证一致性</strong>。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>1.假设有一个进程A，每小时准点给用户发送一条短信”Hello world”，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况。<br>2.假设部署在两台机器，那么问题来了，用户每个小时就会收到两条”Hello world”，信息就重复了<br>3.我们希望只发送一条”Hello world”，那么就可以引入分布式锁的概念了。<br>4.进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么就B就放弃此次任务，等待下一个小时。<br>5.问题的核心就在于怎么注册锁，检查锁的存在和注册锁是一个原子性操作，类似MySQL的主键，存在则不能insert，就说是你不能把我的锁覆盖了，你得等着。<br>6.我们有多种方式可以实现分布式锁，最简单的就是以每小时准点这个时间作为主键，到MySQL写入一条数据，利用数据库来维持一致性。</p>
<h2 id="针对分布式锁的实现，目前比较常用的有以下几种方案："><a href="#针对分布式锁的实现，目前比较常用的有以下几种方案：" class="headerlink" title="针对分布式锁的实现，目前比较常用的有以下几种方案："></a>针对分布式锁的实现，目前比较常用的有以下几种方案：</h2><p>1.基于数据库实现分布式锁<br>2.基于缓存（redis，memcached）实现分布式锁<br>3.基于Zookeeper实现分布式锁</p>
]]></content>
    
    <summary type="html">
    
      分布式锁的基本原理的理解和描述
    
    </summary>
    
      <category term="分布式" scheme="https://stefanma.github.io/categories/distributed/"/>
    
    
      <category term="Java" scheme="https://stefanma.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="https://stefanma.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://stefanma.github.io/2016/05/03/hello-world/"/>
    <id>https://stefanma.github.io/2016/05/03/hello-world/</id>
    <published>2016-05-03T13:27:57.000Z</published>
    <updated>2017-03-05T14:49:33.553Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a> 
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
